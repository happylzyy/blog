<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui"><meta name="renderer" content="webkit"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="theme-color" content="#000000"><meta http-equiv="window-target" content="_top"><title>Linux操作系统原理与应用 | happylzyy&#39;s blog</title><meta name="description" content="HulGodhel 于 2020.11.06   操作系统概述  认识操作系统 可以从不同的角度来认识操作系统。   从使用者的角度，操作系统使得计算机易于使用； 比如执行文件复制操作cp dir1&#x2F;a.tzt dir2&#x2F;b.txt过程中，首先，文件的概念是从操作系统中抽象出来的，没有文件，就必须指定数据的具体物理位置，如柱头磁道扇区等等，其次，复杂的IO操作也由操作系统完成，最后，命令的执行还涉"><meta property="og:type" content="article"><meta property="og:title" content="Linux操作系统原理与应用"><meta property="og:url" content="http://happylzyy.github.io/2020/11/06/linux/index.html"><meta property="og:site_name" content="happylzyy&#39;s blog"><meta property="og:description" content="HulGodhel 于 2020.11.06   操作系统概述  认识操作系统 可以从不同的角度来认识操作系统。   从使用者的角度，操作系统使得计算机易于使用； 比如执行文件复制操作cp dir1&#x2F;a.tzt dir2&#x2F;b.txt过程中，首先，文件的概念是从操作系统中抽象出来的，没有文件，就必须指定数据的具体物理位置，如柱头磁道扇区等等，其次，复杂的IO操作也由操作系统完成，最后，命令的执行还涉"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2020-11-06T15:24:35.000Z"><meta property="article:modified_time" content="2021-05-12T03:09:58.230Z"><meta property="article:author" content="Zhaoyang Liu"><meta property="article:tag" content="Linux"><meta name="twitter:card" content="summary"><link rel="canonical" href="http://happylzyy.github.io/2020/11/06/linux/index.html"><link rel="alternate" href="/atom.xml" title="happylzyy&#39;s blog" type="application/atom+xml"><link rel="icon" href="/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body class="main-center" itemscope itemtype="http://schema.org/WebPage"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="slimContent"><div class="navbar-header"><div class="profile-block text-center"><a id="avatar" href="https://github.com/happylzyy" target="_blank"><img class="img-circle img-rotate" src="https://www.gravatar.com/avatar/b92f7668d0c3b69074a6839e1167cbbb?s=128" width="200" height="200"></a><h2 id="name" class="hidden-xs hidden-sm">Zhaoyang Liu</h2><h3 id="title" class="hidden-xs hidden-sm hidden-md">Student &amp; Engineer</h3><small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Qinhuangdao, China</small></div><div class="search" id="search-form-wrap"><form class="search-form sidebar-form"><div class="input-group"><input type="text" class="search-form-input form-control" placeholder="搜索"> <span class="input-group-btn"><button type="submit" class="search-form-submit btn btn-flat" onclick="return!1"><i class="icon icon-search"></i></button></span></div></form><div class="ins-search"><div class="ins-search-mask"></div><div class="ins-search-container"><div class="ins-input-wrapper"><input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech> <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button></div><div class="ins-section-wrapper"><div class="ins-section-container"></div></div></div></div></div><button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false"><span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span></button></div><nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation"><ul class="nav navbar-nav main-nav menu-highlight"><li class="menu-item menu-item-home"><a href="/."><i class="icon icon-home-fill"></i> <span class="menu-title">首页</span></a></li><li class="menu-item menu-item-archives"><a href="/archives"><i class="icon icon-archives-fill"></i> <span class="menu-title">归档</span></a></li><li class="menu-item menu-item-categories"><a href="/categories"><i class="icon icon-folder"></i> <span class="menu-title">分类</span></a></li><li class="menu-item menu-item-tags"><a href="/tags"><i class="icon icon-tags"></i> <span class="menu-title">标签</span></a></li><li class="menu-item menu-item-repository"><a href="/repository"><i class="icon icon-project"></i> <span class="menu-title">项目</span></a></li><li class="menu-item menu-item-about"><a href="/about"><i class="icon icon-cup-fill"></i> <span class="menu-title">关于</span></a></li></ul><ul class="social-links"><li><a href="https://github.com/happylzyy" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="https://twitter.com/hulgodhel" target="_blank" title="Twitter" data-toggle="tooltip" data-placement="top"><i class="icon icon-twitter"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul></nav></div></header><aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><div class="widget"><h3 class="widget-title">公告</h3><div class="widget-body"><div id="board"><div class="content"><p>欢迎交流与分享经验!</p></div></div></div></div><div class="widget"><h3 class="widget-title">分类</h3><div class="widget-body"><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F/">嵌入式系统</a><span class="category-list-count">1</span></li></ul></div></div><div class="widget"><h3 class="widget-title">标签</h3><div class="widget-body"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Embedded/" rel="tag">Embedded</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/" rel="tag">Git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/" rel="tag">Linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo-katex/" rel="tag">hexo katex</a><span class="tag-list-count">1</span></li></ul></div></div><div class="widget"><h3 class="widget-title">标签云</h3><div class="widget-body tagcloud"><a href="/tags/Embedded/" style="font-size:13px">Embedded</a> <a href="/tags/Git/" style="font-size:13px">Git</a> <a href="/tags/Linux/" style="font-size:13px">Linux</a> <a href="/tags/hexo-katex/" style="font-size:13px">hexo katex</a></div></div><div class="widget"><h3 class="widget-title">归档</h3><div class="widget-body"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a><span class="archive-list-count">2</span></li></ul></div></div><div class="widget"><h3 class="widget-title">最新文章</h3><div class="widget-body"><ul class="recent-post-list list-unstyled no-thumbnail"><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/Hexo/">Hexo</a></p><p class="item-title"><a href="/2021/03/29/katex/" class="title">Hexo中添加KaTex支持LaTex公式渲染</a></p><p class="item-date"><time datetime="2021-03-29T13:45:00.000Z" itemprop="datePublished">2021-03-29</time></p></div></li><li><div class="item-inner"><p class="item-category"></p><p class="item-title"><a href="/2021/02/27/hello-world/" class="title">Hello World</a></p><p class="item-date"><time datetime="2021-02-27T14:23:04.144Z" itemprop="datePublished">2021-02-27</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/Linux/">Linux</a></p><p class="item-title"><a href="/2020/11/06/linux/" class="title">Linux操作系统原理与应用</a></p><p class="item-date"><time datetime="2020-11-06T15:24:35.000Z" itemprop="datePublished">2020-11-06</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F/">嵌入式系统</a></p><p class="item-title"><a href="/2020/06/07/embedded-system/" class="title">嵌入式系统学习笔记</a></p><p class="item-date"><time datetime="2020-06-07T01:20:09.000Z" itemprop="datePublished">2020-06-07</time></p></div></li><li><div class="item-inner"><p class="item-category"><a class="category-link" href="/categories/Git/">Git</a></p><p class="item-title"><a href="/2020/06/06/git/" class="title">Git 学习笔记</a></p><p class="item-date"><time datetime="2020-06-06T06:00:00.000Z" itemprop="datePublished">2020-06-06</time></p></div></li></ul></div></div></div></aside><aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar"><div class="slimContent"><nav id="toc" class="article-toc"><h3 class="toc-title">文章目录</h3><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">操作系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.1.</span> <span class="toc-text">认识操作系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95"><span class="toc-number">1.2.</span> <span class="toc-text">操作系统的发展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%BC%94%E5%8F%98"><span class="toc-number">1.2.1.</span> <span class="toc-text">操作系统的演变</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E5%8F%91%E5%B1%95%E8%BD%A8%E8%BF%B9"><span class="toc-number">1.2.2.</span> <span class="toc-text">硬件发展轨迹</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%8F%91%E5%B1%95%E8%BD%A8%E8%BF%B9"><span class="toc-number">1.2.3.</span> <span class="toc-text">软件发展轨迹</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%86%85%E6%A0%B8%E4%B8%8E%E5%BE%AE%E5%86%85%E6%A0%B8"><span class="toc-number">1.2.4.</span> <span class="toc-text">单内核与微内核</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unixlinux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.3.</span> <span class="toc-text">Unix&#x2F;Linux操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A0%87%E5%87%86posix"><span class="toc-number">1.3.1.</span> <span class="toc-text">操作系统标准POSIX</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gnu%E5%92%8Clinux"><span class="toc-number">1.3.2.</span> <span class="toc-text">GNU和Linux</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#linux-%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.3.3.</span> <span class="toc-text">Linux 开发模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linux%E5%86%85%E6%A0%B8"><span class="toc-number">1.4.</span> <span class="toc-text">Linux内核</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#linux%E5%86%85%E6%A0%B8%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.4.1.</span> <span class="toc-text">Linux内核子系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#linux%E5%86%85%E6%A0%B8%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="toc-number">1.4.2.</span> <span class="toc-text">Linux内核源代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80"><span class="toc-number">2.</span> <span class="toc-text">内存寻址</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80%E7%AE%80%E4%BB%8B"><span class="toc-number">2.1.</span> <span class="toc-text">内存寻址简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ia32%E5%AF%84%E5%AD%98%E5%99%A8%E7%AE%80%E4%BB%8B"><span class="toc-number">2.1.1.</span> <span class="toc-text">IA32寄存器简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80-%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80-%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80"><span class="toc-number">2.1.2.</span> <span class="toc-text">物理地址、虚拟地址、线性地址</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6"><span class="toc-number">2.2.</span> <span class="toc-text">分段机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%8F%8A%E4%BF%9D%E6%8A%A4"><span class="toc-number">2.2.1.</span> <span class="toc-text">地址转换及保护</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#linux%E4%B8%AD%E7%9A%84%E6%AE%B5%E6%9C%BA%E5%88%B6"><span class="toc-number">2.2.2.</span> <span class="toc-text">Linux中的段机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6"><span class="toc-number">2.3.</span> <span class="toc-text">分页机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8"><span class="toc-number">2.3.1.</span> <span class="toc-text">页表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E7%9B%AE%E5%BD%95"><span class="toc-number">2.3.2.</span> <span class="toc-text">页目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E9%A1%B9%E5%B1%9E%E6%80%A7"><span class="toc-number">2.3.3.</span> <span class="toc-text">页表项属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%E5%88%B0%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.3.4.</span> <span class="toc-text">线性地址到物理地址的转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98cache"><span class="toc-number">2.3.5.</span> <span class="toc-text">页面高速缓存（cache）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linux-%E4%B8%AD%E7%9A%84%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6"><span class="toc-number">2.4.</span> <span class="toc-text">Linux 中的分页机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux%E4%B8%AD%E7%9A%84%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80"><span class="toc-number">3.</span> <span class="toc-text">Linux中的汇编语言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#att%E4%B8%8Eintel%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%AF%94%E8%BE%83"><span class="toc-number">3.1.</span> <span class="toc-text">AT&amp;T与Intel汇编语言比较</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BC%80"><span class="toc-number">3.1.1.</span> <span class="toc-text">前缀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E7%9A%84%E6%96%B9%E5%90%91"><span class="toc-number">3.1.2.</span> <span class="toc-text">操作数的方向</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%8D%95%E5%85%83%E6%93%8D%E4%BD%9C%E6%95%B0"><span class="toc-number">3.1.3.</span> <span class="toc-text">内存单元操作数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%A0%81%E5%90%8E%E7%BC%80"><span class="toc-number">3.1.4.</span> <span class="toc-text">操作码后缀</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#att%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="toc-number">3.2.</span> <span class="toc-text">AT&amp;T汇编语言相关知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gnu%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8Fgnu-assemblygas%E5%92%8C%E8%BF%9E%E6%8E%A5%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.2.1.</span> <span class="toc-text">GNU汇编程序（GNU ASsembly,GAS）和连接程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#att%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E8%8A%82section"><span class="toc-number">3.2.2.</span> <span class="toc-text">AT&amp;T汇编语言中的节（section）</span></a></li></ol></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number"></span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">进程介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">程序和进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">进程的层次结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">1.3.</span> <span class="toc-text">进程的状态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-number">2.</span> <span class="toc-text">进程控制块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81-2"><span class="toc-number">2.1.</span> <span class="toc-text">进程的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">2.2.</span> <span class="toc-text">进程标识符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.3.</span> <span class="toc-text">进程之间的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%E7%9A%84%E5%AD%98%E6%94%BE"><span class="toc-number">2.4.</span> <span class="toc-text">进程控制块的存放</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">进程的组织方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%93%BE%E8%A1%A8"><span class="toc-number">3.1.</span> <span class="toc-text">进程链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8"><span class="toc-number">3.2.</span> <span class="toc-text">散列表</span></a></li></ol></li></ol></li></nav></div></aside><main class="main" role="main"><div class="content"><article id="post-linux" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting"><div class="article-header"><h1 class="article-title" itemprop="name">Linux操作系统原理与应用</h1><div class="article-meta"><span class="article-date"><i class="icon icon-calendar-check"></i> <a href="/2020/11/06/linux/" class="article-date"><time datetime="2020-11-06T15:24:35.000Z" itemprop="datePublished">2020-11-06</time> </a></span><span class="article-category"><i class="icon icon-folder"></i> <a class="article-category-link" href="/categories/Linux/">Linux</a> </span><span class="article-tag"><i class="icon icon-tags"></i> <a class="article-tag-link-link" href="/tags/Linux/" rel="tag">Linux</a> </span><span class="article-read hidden-xs"><i class="icon icon-eye-fill" aria-hidden="true"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span> </span></span><span class="post-comment"><i class="icon icon-comment"></i> <a href="/2020/11/06/linux/#comments" class="article-comment-link">评论</a></span> <span class="post-wordcount hidden-xs" itemprop="wordCount">字数统计: 6k(字)</span> <span class="post-readcount hidden-xs" itemprop="timeRequired">阅读时长: 21(分)</span></div></div><div class="article-entry marked-body" itemprop="articleBody"><p>HulGodhel 于 2020.11.06</p><hr><h2 id="操作系统概述"><a class="markdownIt-Anchor" href="#操作系统概述"></a> 操作系统概述</h2><h3 id="认识操作系统"><a class="markdownIt-Anchor" href="#认识操作系统"></a> 认识操作系统</h3><p>可以从不同的角度来认识操作系统。</p><ul><li><p>从使用者的角度，操作系统使得计算机易于使用；</p><p>比如执行文件复制操作<code>cp dir1/a.tzt dir2/b.txt</code>过程中，首先，文件的概念是从操作系统中抽象出来的，没有文件，就必须指定数据的具体物理位置，如柱头磁道扇区等等，其次，复杂的IO操作也由操作系统完成，最后，命令的执行还涉及到其他的复杂操作，这些繁琐的事务完全由操作系统处理。</p><p>操作系统图形化的界面也使得计算机易于使用。</p></li><li><p>从程序员角度，操作系统把软件开发人员从与硬件打交道的繁琐事务中解放出来；</p><p>编程的过程中不必关心实现的细节，可以直接调用系统API实现相关功能。操作系统是程序与硬件之间的桥梁，任何程序的运行只有借助操作系统才能顺利完成，操作系统是应用程序运行d基础设施。</p></li><li><p>从设计者的角度，操作系统可以对计算机系统中的各种软、硬件资源进行有效的管理。</p><p>为了对软硬件资源进行有效的管理，操作系统必须包含以下几个部分：</p><ol><li>操作系统接口</li><li>CPU管理</li><li>内存管理</li><li>设备管理</li><li>文件管理</li></ol></li></ul><p>综上，</p><blockquote><p><strong>操作系统</strong>是计算机系统中的一个系统软件，是一些程序模块的集合——他们尽可能以有效、合理的方式组织和管理计算机的软、硬件资源，合理地组织计算机的工作流程，控制程序的执行，并向用户提供各种服务功能，使得用户能够灵活、方便、有效地使用计算机，使整个计算机系统能高效、舒畅地运行。</p></blockquote><h3 id="操作系统的发展"><a class="markdownIt-Anchor" href="#操作系统的发展"></a> 操作系统的发展</h3><h4 id="操作系统的演变"><a class="markdownIt-Anchor" href="#操作系统的演变"></a> 操作系统的演变</h4><ul><li>单道批处理系统 串行执行预先组织好的一组任务，IO操作时CPU等待数据传输完成，浪费时间。</li><li>多道批处理系统 处理器可以交错运行多个程序。</li><li>分时系统 将处理器的运行时间分成数片，平均或者依照一定的权重分发给系统中的各用户使用。</li></ul><h4 id="硬件发展轨迹"><a class="markdownIt-Anchor" href="#硬件发展轨迹"></a> 硬件发展轨迹</h4><p>机械–电子管–晶体管–集成电路–大规模集成电路</p><h4 id="软件发展轨迹"><a class="markdownIt-Anchor" href="#软件发展轨迹"></a> 软件发展轨迹</h4><p>无软件–系统雏形–操作系统理论成型–现代操作系统–网络时代–开源软件时代</p><h4 id="单内核与微内核"><a class="markdownIt-Anchor" href="#单内核与微内核"></a> 单内核与微内核</h4><p>单内核，集中式操作系统，系统是个大模块，可分为若干逻辑模块，模块间以函数直接调用为交互。优点是内部调用效率高，缺点是各模块之间界限不特别清晰，系统升级或修改时牵一发而动全身，较难维护。</p><p>微内核，将操作系统中内存管理、设备管理等高级服务功能尽可能从内核中分离出来，使内核简洁可靠。优点是</p><ul><li>充分的模块化，方便第三方开发和设计模块。</li><li>未被使用的模块可以不必运行。</li><li>具有很高的可移植性。</li></ul><p>缺点是各模块与微内核之间通过通信机制交互，系统运行效率低。微内核是面向对象理论在操作系统设计中应用的产物。</p><h3 id="unixlinux操作系统"><a class="markdownIt-Anchor" href="#unixlinux操作系统"></a> Unix/Linux操作系统</h3><p>1969年 Ken Thompson 和 Dennis M. Ritchie 开发 Unix</p><p>1990年 Linus Torvalds 开发 Linux</p><h4 id="操作系统标准posix"><a class="markdownIt-Anchor" href="#操作系统标准posix"></a> 操作系统标准POSIX</h4><p>POSIX（可移植操作系统接口）由IEEE制定，由 ISO 接受为国际标准。其中POSIX 1003.1标准定义了一个最小的Unix操作系统接口，任何系统只有符合这个标准，才有可能运行Unix程序。</p><h4 id="gnu和linux"><a class="markdownIt-Anchor" href="#gnu和linux"></a> GNU和Linux</h4><p>GNU（GNU is Not Unix）是自由软件基金会的一个项目，该项目的目标是开发一个自由的Unix版本HURD。</p><p>Linux的开发使用了很多GNU工具，Linux内核、GNU工具以及其他一些自由软件组成了人们常说的Linux系统或Linux发行版。</p><h4 id="linux-开发模式"><a class="markdownIt-Anchor" href="#linux-开发模式"></a> Linux 开发模式</h4><p>开放与协作的开发模式，发挥集体智慧，减少重复劳动，经历了各种各样的测试和考验，具有很好的稳定性。</p><h3 id="linux内核"><a class="markdownIt-Anchor" href="#linux内核"></a> Linux内核</h3><p>Linux内核不是孤立的，需要放在整个系统中去研究。Linux系统由四部分组成：</p><ul><li><p>用户进程</p></li><li><p>系统调用接口</p><p>系统调用是内核代码的一部分</p></li><li><p>Linux内核</p></li><li><p>硬件</p></li></ul><p>Linux内核包含了系统调用接口和内核子系统。从程序员的角度，内核提供了一个与计算机硬件等价的、 扩展或虚拟的计算平台，它抽象了许多硬件细节，使程序能够按照某种统一的方式进行数据处理。从用户角度讲，内核是一个资源管理者，用户可以以某种易于理解的方式组织自己的数据。</p><h4 id="linux内核子系统"><a class="markdownIt-Anchor" href="#linux内核子系统"></a> Linux内核子系统</h4><p>Linux内核除了系统调用之外，由以下5个主要的子系统组成：</p><ul><li><p>进程调度</p><p>Linux使用了比较简单的、基于优先级和时间片的进程调度算法。</p></li><li><p>内存管理</p><p>支持虚拟内存，因为虚拟内存管理需要硬件支持，所以内存管理分为硬件无关部分和硬件相关部分。</p></li><li><p>虚拟文件系统</p></li><li><p>网络</p></li><li><p>进程间通信（IPC）</p></li></ul><p>处于中心地位的是进程调度。</p><h4 id="linux内核源代码"><a class="markdownIt-Anchor" href="#linux内核源代码"></a> Linux内核源代码</h4><p>版本号格式：x.y.z</p><p>第二位为偶数则为产品化版本，第二位为奇数则为实验版本，实验版本最初是产品化版本的副本；产品化版本只修改错误，实验版本继续增加新功能，到实验版本经测试稳定后再复制生成新的产品化版本。</p><p>Linux内核源代码位于<code>/user/src/linux</code>目录下，每个目录或子目录可以看作一个模块（结构化程序设计）</p><ul><li><code>include/</code>建立内核代码所需的大部分包含文件</li><li><code>init/</code>内核的初始化代码，这是内核工作的起点</li><li><code>arch/</code>包含Linux支持的所有硬件结构的内核代码</li><li><code>drivers/</code>内核中所有的设备驱动程序</li><li><code>fs/</code>所有文件系统的代码</li><li><code>net/</code>关于网络的代码</li><li><code>mm/</code>所有内存管理代码</li><li><code>ipc/</code>进程间通信的代码</li><li><code>kernel/</code>主内核代码</li></ul><h2 id="内存寻址"><a class="markdownIt-Anchor" href="#内存寻址"></a> 内存寻址</h2><p>Linux的设计中，它把与硬件相关的代码全部放到了arch目录下，对于众多的硬件平台，大家最熟悉的就是i386，即 Intel 80386 的体系结构。</p><h3 id="内存寻址简介"><a class="markdownIt-Anchor" href="#内存寻址简介"></a> 内存寻址简介</h3><p>Alan Turing 设想了一种结构简单但运算能力几乎无限强大的机器，它由控制器、读写头和一段假设无限长的带子组成。工作带相当于存储器，被划分成为大小相同的小格子，每个格子可以写一个字母，读写头可以在带子上随意移动，而控制器可以要求读写头读取下方的工作带上的字母。这种“数据连续存储和选择读取”的思想是目前人们使用的几乎所有机器运行机制的灵魂。计算机体系结构的核心问题之一就是如何有效地进行内存寻址。</p><p>Intel公司发明的8086处理器是16位的，它的设计寻址目标是1MB的内存空间，所以地址总线扩展到了20位，如何将16位地址映射到20位的地址空间，Intel公司设计了一个非常巧妙的方法，分段的方法。</p><p>8086处理器中设置了四个段寄存器：CS、DS、SS、ES，分别用于可执行代码段、 数据段、堆栈段及扩展段。每个段寄存器都是16位的，每条“访内”指令中的内部地址也是16位的，访问内存时，CPU自动地将内部地址与某个段寄存器的内容相加，即段寄存器左移4位加偏移地址，从而将16位地址映射到20位地址。</p><p>1982年，Intel 80286问世，他的地址空间长度增加到了24位，并且引入了保护模式的概念。为了与过去兼容，以前的模式被成为实模式。80386的数据总线扩展到32位，但仍然保留了段寄存器16位，80386以后的处理器统称为<strong>IA32</strong> (32bit Intel Architecture)。</p><h4 id="ia32寄存器简介"><a class="markdownIt-Anchor" href="#ia32寄存器简介"></a> IA32寄存器简介</h4><p>通用寄存器：</p><p>EAX，EBX，ECX，EDX，EBP，ESP，ESI，EDI，8个通用寄存器是8086寄存器的超集，可以拆开来用，他们的低位部分被当成8个16位寄存器，AX，BX……DI，AX……BX还可以继续分为8个8位寄存器，AH、AL……DH、DL。</p><p>段寄存器：</p><p>16位，保存的不是段的基地址，而是某个段的选择符，段基地址存放在描述符表中。</p><p>指令指针寄存器和标志寄存器：</p><p>指令指针寄存器EIP中存放下一条将要执行的指令的偏移量，这个偏移量是相对于代码段寄存器CS而言的。偏移量加段基地址就是下一条指令的地址。标志寄存器EFLAGS很多与16位FLAGS相同。</p><p>控制寄存器：</p><p>80386有4个32位控制寄存器：</p><p>CR0中主要介绍0位和31位，PE（Protected Enable）和PG（PaGing enable）。</p><table><thead><tr><th>PG</th><th>PE</th><th>工作方式</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>实模式，8080操作</td></tr><tr><td>0</td><td>1</td><td>保护模式，但不允许分页</td></tr><tr><td>1</td><td>0</td><td>出错（权限大小倒置）</td></tr><tr><td>1</td><td>1</td><td>允许分页的保护模式</td></tr></tbody></table><p>CR1未定义。</p><p>CR2页故障线性地址寄存器，保存最后一次出现缺页的全32位线性地址。</p><p>CR3是页目录基址寄存器，保存页目录的物理地址。</p><h4 id="物理地址-虚拟地址-线性地址"><a class="markdownIt-Anchor" href="#物理地址-虚拟地址-线性地址"></a> 物理地址、虚拟地址、线性地址</h4><p>对于操作系统来说，它既需要知道物理内存地址，又需要提供一套程序员使用的与硬件无关的虚拟的内存空间。</p><p>主板上的物理内存条所提供的内存空间称为物理内存空间，其中每个内存单元的实际地址称为物理地址；操作系统为程序员提供的与硬件无关的内存空间称为虚拟地址空间（或地址空间），其中的地址称为虚拟地址，通常用“段：偏移量”来描述。</p><p>线性地址空间是指一段连续的、不分段的、范围为0～4GB的地址空间，一个线性地址就是线性地址空间中的绝对地址。</p><p>地址的转换由内存管理单元（MMU）完成，其功能是把虚拟地址映射为物理地址。MMU是一种硬件电路，有分段和分页两个部分组成。分段机制将虚拟地址转换成线性地址，分页机制将线性地址转换成物理地址。</p><h3 id="分段机制"><a class="markdownIt-Anchor" href="#分段机制"></a> 分段机制</h3><p>段描述符表由段描述符组成，每个段描述符占8个字节（段基地址32位，界限20位，属性12位），在保护模式下有三种表：全局描述符表、中断描述符表、局部描述符表。</p><p>保护模式下IA32虚拟地址“段：偏移量”中的段不是段基地址，而是一个索引，段基地址通过索引在段描述符表中查找，因此保护模式下段寄存器中储存的是段描述符表的索引。段寄存器又可以叫做选择符，选择符有三个域，3～15位是索引域；第二位是TI位选择域，TI为0表示全局描述符表索引，TI为1表示局部描述符表索引；第0位和第1位为请求者的特权级RPL，保护模式提供4种特权级，一般操作系统只用到两个，00表示最高特权级，对应内核态，11表示最低特权级，对应用户态。</p><h4 id="地址转换及保护"><a class="markdownIt-Anchor" href="#地址转换及保护"></a> 地址转换及保护</h4><ul><li>段寄存器中装入段选择符，同时把某偏移地址放入某寄存器（如ESI、EDI）中；</li><li>根据段选择符中的索引、TI、RPL，进行一系列合法性检查，如果没有问题进行下一步；</li><li>将段描述符表中对应的段基地址和放入某寄存器中的偏移地址相加形成线性地址。</li></ul><h4 id="linux中的段机制"><a class="markdownIt-Anchor" href="#linux中的段机制"></a> Linux中的段机制</h4><p>大部分硬件平台都不支持分段机制，只支持分页机制，为了绕过IA32的分段机制，让段的基地址为0，段的界限为4GB，将虚拟地址直接映射到线性地址。</p><h3 id="分页机制"><a class="markdownIt-Anchor" href="#分页机制"></a> 分页机制</h3><p>线性地址划分为若干<strong>页</strong>，相应地，把物理地址空间划分为若干<strong>物理块（页面）</strong>，一般页的大小为4KB。</p><h4 id="页表"><a class="markdownIt-Anchor" href="#页表"></a> 页表</h4><p>由于页的大小是4KB，所以对应的物理基地址一定是4KB的整数倍，因此基地址的低12位总是0，那么可以用这12位存放页的属性，这样，32位足以描述页的映射关系，页表中的每一项（页表项）占4个字节就足够。</p><p>因为4GB线性空间划分为1M个4KB页，一个页表项占用4B，页表需要占用4MB空间，而且还要求是连续的空间，这样不现实，因此引入两级页表机制。</p><h4 id="页目录"><a class="markdownIt-Anchor" href="#页目录"></a> 页目录</h4><p>页目录记录页表的信息，4MB的页表数据再次分页，可以划分成1K个4KB页，每个页目录占用32位，因此页目录共占用4KB空间，刚好是一个页表的大小。</p><p>页目录具有与页表相似的结构：低12位总是为0，存放页目录的属性；高20位存放指向页表所在物理页面在内存的起始地址。</p><p>通过分页机制，可以得到具有两级页表的线性地址结构：</p><p>页目录：页：页内偏移量</p><p>伪代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> dir:<span class="number">10</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> page:<span class="number">10</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> offset:<span class="number">12</span>;</span><br><span class="line">&#125;LinearAddr;</span><br></pre></td></tr></table></figure><h4 id="页表项属性"><a class="markdownIt-Anchor" href="#页表项属性"></a> 页表项属性</h4><p>31～12位，物理页面基地址；11～0位，页属性</p><p>属性包括：</p><ul><li>0位，Present，若P=1，表示该页已装入内存，P=0则表示该页不在内存中；</li><li>1位和2位，read/write和user/supervisor位，这两位为页面提供硬件保护，当U/S=0时，只有内核态才能进行寻址，为1时，内核态和用户态都能寻址；</li><li>3位，page write-through，表示是否采用写透方式，即写内存又写高速缓存，为1表示启用写透方式；</li><li>4位，page cache disable，表示是否启用高速缓存，为1表示启用；</li><li>5位，访问位，当对相应的物理页面进行访问时，该位为1；</li><li>7位，page size，只适用于页目录项，如果为1，则页目录项指的是4MB大小的页；</li><li>9～11位，操作系统专用位，Linux没有将它们做特殊之用。</li></ul><h4 id="线性地址到物理地址的转换"><a class="markdownIt-Anchor" href="#线性地址到物理地址的转换"></a> 线性地址到物理地址的转换</h4><p>二级页表线性地址结构：</p><p>页目录（10位）：页（10位）：页内偏移量（12位）</p><p>转换成物理地址步骤：</p><ol><li>页目录10位左移2位后与CR3中的页目录起始地址相加，得到页目录项的物理地址；</li><li>读取页目录项，得到页表的起始地址；</li><li>页10位左移2位后与页表起始地址相加，得到页表项的物理地址；</li><li>读取页表项，得到物理页面起始地址；</li><li>物理页面地址加页内偏移量，得到线性地址对应的物理地址。</li></ol><h4 id="页面高速缓存cache"><a class="markdownIt-Anchor" href="#页面高速缓存cache"></a> 页面高速缓存（cache）</h4><p>CPU高速缓存自动保留处理器最近使用的32个页表项，下次访问就不必到内存中找了，平均来说大约有90%的命中率，大大加快访问速度。</p><h3 id="linux-中的分页机制"><a class="markdownIt-Anchor" href="#linux-中的分页机制"></a> Linux 中的分页机制</h3><p>Linux主要采用分页机制来实现虚拟内存管理，因为</p><ul><li>Linux绕过IA32的分段机制，段地址为0，所有进程都使用相同的线性地址空间，这样内存管理比较简单；</li><li>其他RISC处理器分段功能有限，为了保证可移植性。</li></ul><p>Linux使用三级分页模式，这是因为许多处理器是64位的，线性地址结构为：</p><p>总目录：中间目录：页表：页内偏移量</p><h2 id="linux中的汇编语言"><a class="markdownIt-Anchor" href="#linux中的汇编语言"></a> Linux中的汇编语言</h2><p>Linux 来源于Unix，Linux所使用的i386语言也起源于Unix。</p><h3 id="att与intel汇编语言比较"><a class="markdownIt-Anchor" href="#att与intel汇编语言比较"></a> AT&amp;T与Intel汇编语言比较</h3><h4 id="前缀"><a class="markdownIt-Anchor" href="#前缀"></a> 前缀</h4><p>Intel汇编语言中，寄存器和立即数都没有前缀，在AT&amp;T汇编语言中，寄存器前冠以<code>%</code>，立即数前冠以<code>$</code>。</p><p>Intel汇编语言中，十六进制和十进制数后缀分别为<code>h</code>和<code>b</code>，AT&amp;T汇编语言中，十六进制立即数前冠以<code>0x</code>。</p><h4 id="操作数的方向"><a class="markdownIt-Anchor" href="#操作数的方向"></a> 操作数的方向</h4><p>操作数方向相反，如</p><p>Intel <code>mov eax,[ecx]</code></p><p>AT&amp;T <code>movl (%ecx),eax</code></p><h4 id="内存单元操作数"><a class="markdownIt-Anchor" href="#内存单元操作数"></a> 内存单元操作数</h4><p>Intel中使用<code>[]</code>，AT&amp;T中使用<code>()</code>，如</p><p><code>mov eax, [ebx+5]</code></p><p><code>movl 5(%ebx), %eax</code></p><h4 id="操作码后缀"><a class="markdownIt-Anchor" href="#操作码后缀"></a> 操作码后缀</h4><p>AT&amp;T的操作码后面有后缀，<code>l</code>表示长整数32位，<code>w</code>表示字16位，<code>b</code>表示字节8位；而在Intel汇编语言中，则要在内存单元操作数前加<code>byte ptr</code>或<code>dword ptr</code>。</p><h3 id="att汇编语言相关知识"><a class="markdownIt-Anchor" href="#att汇编语言相关知识"></a> AT&amp;T汇编语言相关知识</h3><p>在Linux源代码中，汇编语言扩展名为<code>.S</code>。</p><p>Linux中<code>objdump</code>命令可以进行反汇编。</p><p>Linux中最常见的可执行文件格式是ELF格式，<s>ld连接程序对其代码段虚拟地址的安排总是从<code>0x8000000</code>开始</s>， <em>似乎后续版本的ld不再这样做</em>。</p><h4 id="gnu汇编程序gnu-assemblygas和连接程序"><a class="markdownIt-Anchor" href="#gnu汇编程序gnu-assemblygas和连接程序"></a> GNU汇编程序（GNU ASsembly,GAS）和连接程序</h4><p>汇编和连接有两种方式：</p><ol><li><p>GAS和ld</p><p><code>as filename.S -o filename.o</code>命令生成目标文件；</p><p><code>ld filename.o -o filename</code>命令生成可执行文件。</p></li><li><p>GCC</p><p><code>gcc -o filename filename.S</code>一步到位，完成汇编和连接。</p></li></ol><h4 id="att汇编语言中的节section"><a class="markdownIt-Anchor" href="#att汇编语言中的节section"></a> AT&amp;T汇编语言中的节（section）</h4><p>节由<code>.section</code>关键词标识，编写汇编语言程序至少需要三种节：</p><ul><li><p><code>.section.data</code></p><p>包含已初始化的数据。</p></li><li><p><code>.section.bss</code></p><p>包含未初始化的数据，系统将程序装入内存时该部分变量都置0，这个节的变量不占用磁盘空间。</p><p>bss和data节在编译时会在4字节上对齐。</p></li><li><p><code>.section.text</code></p><p>这个节包含程序的代码，它是只读的。</p></li></ul><h1 id="进程"><a class="markdownIt-Anchor" href="#进程"></a> 进程</h1><h2 id="进程介绍"><a class="markdownIt-Anchor" href="#进程介绍"></a> 进程介绍</h2><p>进程是对正在运行的程序的一种抽象，是操作系统的核心概念之一。</p><p>现在所有的计算机都可以同时做很多事情，而CPU只有一个（或者数量有限），严格来说，CPU一次只能运行一道程序，CPU通过在不同程序之间来回切换来运行多个程序，这样就给用户一种同时运行的感觉，这种CPU在多道程序之间来回快速切换称为伪并行。进程概念的引入使得并行更容易理解和处理。</p><h3 id="程序和进程"><a class="markdownIt-Anchor" href="#程序和进程"></a> 程序和进程</h3><p>程序是文件，是机器代码指令和数据的集合，保存在外部存储器上，称为可执行映像（excutable image），如exe文件。</p><p>程序保存了一系列用户希望完成的工作和步骤，它仅仅是静态的体现在纸面上，而程序运行的具体实现过程由进程来完成。</p><p>进程代表程序的执行过程，它是一个动态的实体，随着程序中指令的运行而不断变化，在某个时刻进程的内容称为进程映像（process image）。</p><p>Linux是多任务操作系统，可以同时运行多个程序，每个程序的执行都有自己的进程，每个进程都有自己的执行环境。CPU在多个程序之间进行切换，也就是在各个进程之间切换，也就是切换进程的执行环境，因此，进程切换又称为“环境切换”或“上下文切换”，上下文指的是进程的执行环境。</p><h3 id="进程的层次结构"><a class="markdownIt-Anchor" href="#进程的层次结构"></a> 进程的层次结构</h3><p>进程是个动态的实体，具有生命周期。</p><p>在Linux系统中，通过fork系统调用来创建一个新的进程。新创建的进程是子进程，子进程同样可以调用fork。每个进程只有一个父进程，但可以有多个子进程，这样形成一棵完整的进程树。</p><h3 id="进程的状态"><a class="markdownIt-Anchor" href="#进程的状态"></a> 进程的状态</h3><p>为了对进程从产生到消亡的这个动态过程进行跟踪和描述，需要定义各种进程状态并制定状态间的转换策略。</p><p>不同操作系统对进程状态的定义不同，通常有三种最基本的进程状态：</p><ul><li>运行态：进程占有CPU，并在CPU上执行</li><li>就绪态：进程已经具备运行条件，但由于CPU忙而暂时不能运行</li><li>阻塞态：进程因等待某种事件的发生而暂时不能运行</li></ul><h2 id="进程控制块"><a class="markdownIt-Anchor" href="#进程控制块"></a> 进程控制块</h2><p>操作系统为了对进程进行管理，将进程的信息存放在一个结构体中，Linux中把这个结构体叫做task_struct。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//Process info</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="进程的状态-2"><a class="markdownIt-Anchor" href="#进程的状态-2"></a> 进程的状态</h3><p>在Linux 的设计中，考虑到任一时刻在CPU上运行的进程最多只有一个，而准备运行的进程有若干个，为了管理方便，把就绪态和运行态合并为一个状态——可运行态。把所有可运行态进程放进一个队列中，调度程序从这个队列中选取进程投入运行。</p><p>所有进程状态如下：</p><ul><li><p>可运行态 TASK_RUNNING</p><p>正在运行或准备运行</p></li><li><p>睡眠（或等待）态</p><ul><li><p>浅度睡眠态</p><p>进程正在被阻塞，等待资源有效时被唤醒，也可由其他进程通过信号或中断唤醒。</p></li><li><p>深度睡眠态</p><p>与浅度睡眠类似，但不可由其他进程通过信号和时钟中断唤醒。</p></li></ul></li><li><p>暂停状态</p><p>进程暂时停止执行等待某种处理，比如正在接受调试的进程。</p></li><li><p>僵死状态</p><p>进程执行结束，但未消亡。此时进程已经结束并释放大部分资源，但尚未释放PCB。</p></li></ul><h3 id="进程标识符"><a class="markdownIt-Anchor" href="#进程标识符"></a> 进程标识符</h3><p>进程标识符（PID）是32位无符号整数，每个进程都有唯一的PID。</p><p>每个进程都属于某个用户组，task_struct结构中定义了用户标识符和组标识符。</p><h3 id="进程之间的关系"><a class="markdownIt-Anchor" href="#进程之间的关系"></a> 进程之间的关系</h3><p>进程之间具有父子关系，一个进程可以创建很多子进程，子进程之间具有兄弟关系。因此task_struct结构需要储存这些关系</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> state;<span class="comment">//进程状态</span></span><br><span class="line">    <span class="keyword">int</span> pid,uid,gid;<span class="comment">//一些标识符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">parent</span>,*<span class="title">child</span>,*<span class="title">o_sibling</span>,*<span class="title">y_sibling</span>;</span><span class="comment">//一些亲属关系</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进程控制块的存放"><a class="markdownIt-Anchor" href="#进程控制块的存放"></a> 进程控制块的存放</h3><p>Linux把每个进程的PCB和内核栈存放在一起，共占用8KB，调用<code>alloc_task_struct()</code>函数分配该内存区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">task_union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> <span class="title">task</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">stack</span>[<span class="number">2408</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把PCB和内核栈放在一起的好处</p><ul><li><p>内核可以方便而快速地找到PCB</p><p><code>p=(struct task_struct *) STACK_POINTER &amp; 0xffffe000</code></p></li><li><p>避免在创建进程时动态分配内存</p><p>Linux中定义了一个current宏，用于表示当前正在运行的进程，可以像全局变量一样使用，如<code>current-&gt;pid</code></p></li></ul><h2 id="进程的组织方式"><a class="markdownIt-Anchor" href="#进程的组织方式"></a> 进程的组织方式</h2><h3 id="进程链表"><a class="markdownIt-Anchor" href="#进程链表"></a> 进程链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">prev_task</span>, *<span class="title">next_task</span>;</span></span><br></pre></td></tr></table></figure><p>链表的头和尾都是init_task，init_task是0号进程，永远不会被删除，它的PCB被静态地分配在内核数据段中。</p><p>要遍历整个链表，定义宏<code>for_each_task()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> for_each_task(p) \</span></span><br><span class="line">	<span class="keyword">for</span>(p = &amp;init_task; (p = p-&gt;next_task) != &amp;init_task;)</span><br></pre></td></tr></table></figure><h3 id="散列表"><a class="markdownIt-Anchor" href="#散列表"></a> 散列表</h3><p>遍历整个链表是个效率很低的行为，为了能够快速根据PID找到PCB，定义了散列表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pid_hashfn(x) \</span></span><br><span class="line">((((x) &gt;&gt; <span class="number">8</span>) ^ (x)) &amp; (PIDHASH_SZ - <span class="number">1</span>))</span><br></pre></td></tr></table></figure></div><div class="article-footer"><blockquote class="mt-2x"><ul class="post-copyright list-unstyled"><li class="post-copyright-link hidden-xs"><strong>本文链接：</strong> <a href="http://happylzyy.github.io/2020/11/06/linux/" title="Linux操作系统原理与应用" target="_blank" rel="external">http://happylzyy.github.io/2020/11/06/linux/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！</li></ul></blockquote><div class="panel panel-default panel-badger"><div class="panel-body"><figure class="media"><div class="media-left"><a href="https://github.com/happylzyy" target="_blank" class="img-burn thumb-sm visible-lg"><img src="https://www.gravatar.com/avatar/b92f7668d0c3b69074a6839e1167cbbb?s=128" class="img-rounded w-full" alt=""></a></div><div class="media-body"><h3 class="media-heading"><a href="https://github.com/happylzyy" target="_blank"><span class="text-dark">Zhaoyang Liu</span><small class="ml-1x">Student &amp; Engineer</small></a></h3><div>Having fun</div></div></figure></div></div></div></article><section id="comments"></section></div><nav class="bar bar-footer clearfix" data-stick-bottom><div class="bar-inner"><ul class="pager pull-left"><li class="prev"><a href="/2021/02/27/hello-world/" title="Hello World"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a></li><li class="next"><a href="/2020/06/07/embedded-system/" title="嵌入式系统学习笔记"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a></li><li class="toggle-toc"><a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="文章目录" role="button"><span>[&nbsp;</span><span>文章目录</span> <i class="text-collapsed icon icon-anchor"></i> <i class="text-in icon icon-close"></i> <span>]</span></a></li></ul><div class="bar-right"><div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div></div></div></nav></main><footer class="footer" itemscope itemtype="http://schema.org/WPFooter"><ul class="social-links"><li><a href="https://github.com/happylzyy" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li><li><a href="https://twitter.com/hulgodhel" target="_blank" title="Twitter" data-toggle="tooltip" data-placement="top"><i class="icon icon-twitter"></i></a></li><li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li></ul><div class="copyright"><div class="publishby">Base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure </a>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>.</div></div></footer><script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script><script>window.jQuery||document.write('<script src="js/jquery.min.js"><\/script>')</script><script src="/js/plugin.min.js"></script><script src="/js/application.js"></script><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(未命名)"},ROOT_URL:"/",CONTENT_URL:"/content.json"}</script><script src="/js/insight.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="//cdn.jsdelivr.net/npm/gitalk@1.4.0/dist/gitalk.min.js"></script><script src="//cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><script type="text/javascript">var gitalk=new Gitalk({clientID:"595d6049487da2d9c45b",clientSecret:"6a59a1d4a49d8b5960e9de716cf905f31b2ebe0d",repo:"happylzyy.github.io",owner:"happylzyy",admin:["happylzyy"],id:md5(location.pathname),distractionFreeMode:!0});gitalk.render("comments")</script></body></html>