<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>happylzyy&#39;s blog</title>
  
  
  <link href="http://happylzyy.github.io/atom.xml" rel="self"/>
  
  <link href="http://happylzyy.github.io/"/>
  <updated>2021-03-29T14:15:38.427Z</updated>
  <id>http://happylzyy.github.io/</id>
  
  <author>
    <name>Zhaoyang Liu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo中添加KaTex支持LaTex公式渲染</title>
    <link href="http://happylzyy.github.io/2021/03/29/katex/"/>
    <id>http://happylzyy.github.io/2021/03/29/katex/</id>
    <published>2021-03-29T13:45:00.000Z</published>
    <updated>2021-03-29T14:15:38.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hexo中添加katex支持latex公式渲染"><a class="markdownIt-Anchor" href="#hexo中添加katex支持latex公式渲染"></a> Hexo中添加KaTex支持LaTex公式渲染</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;hexo中添加katex支持latex公式渲染&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#hexo中添加katex支持latex公式渲染&quot;&gt;&lt;/a&gt; Hexo中添加KaTex支持LaTex公式渲染&lt;/h1&gt;
</summary>
      
    
    
    
    <category term="Hexo" scheme="http://happylzyy.github.io/categories/Hexo/"/>
    
    
    <category term="hexo katex" scheme="http://happylzyy.github.io/tags/hexo-katex/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://happylzyy.github.io/2021/02/27/hello-world/"/>
    <id>http://happylzyy.github.io/2021/02/27/hello-world/</id>
    <published>2021-02-27T14:23:04.144Z</published>
    <updated>2021-02-27T14:23:04.144Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux操作系统原理与应用</title>
    <link href="http://happylzyy.github.io/2020/11/06/linux/"/>
    <id>http://happylzyy.github.io/2020/11/06/linux/</id>
    <published>2020-11-06T15:24:35.000Z</published>
    <updated>2021-05-12T03:09:58.230Z</updated>
    
    <content type="html"><![CDATA[<p>HulGodhel 于 2020.11.06</p><hr /><h2 id="操作系统概述"><a class="markdownIt-Anchor" href="#操作系统概述"></a> 操作系统概述</h2><h3 id="认识操作系统"><a class="markdownIt-Anchor" href="#认识操作系统"></a> 认识操作系统</h3><p>可以从不同的角度来认识操作系统。</p><ul><li><p>从使用者的角度，操作系统使得计算机易于使用；</p><p>比如执行文件复制操作<code>cp dir1/a.tzt dir2/b.txt</code>过程中，首先，文件的概念是从操作系统中抽象出来的，没有文件，就必须指定数据的具体物理位置，如柱头磁道扇区等等，其次，复杂的IO操作也由操作系统完成，最后，命令的执行还涉及到其他的复杂操作，这些繁琐的事务完全由操作系统处理。</p><p>操作系统图形化的界面也使得计算机易于使用。</p></li><li><p>从程序员角度，操作系统把软件开发人员从与硬件打交道的繁琐事务中解放出来；</p><p>编程的过程中不必关心实现的细节，可以直接调用系统API实现相关功能。操作系统是程序与硬件之间的桥梁，任何程序的运行只有借助操作系统才能顺利完成，操作系统是应用程序运行d基础设施。</p></li><li><p>从设计者的角度，操作系统可以对计算机系统中的各种软、硬件资源进行有效的管理。</p><p>为了对软硬件资源进行有效的管理，操作系统必须包含以下几个部分：</p><ol><li>操作系统接口</li><li>CPU管理</li><li>内存管理</li><li>设备管理</li><li>文件管理</li></ol></li></ul><p>综上，</p><blockquote><p><strong>操作系统</strong>是计算机系统中的一个系统软件，是一些程序模块的集合——他们尽可能以有效、合理的方式组织和管理计算机的软、硬件资源，合理地组织计算机的工作流程，控制程序的执行，并向用户提供各种服务功能，使得用户能够灵活、方便、有效地使用计算机，使整个计算机系统能高效、舒畅地运行。</p></blockquote><h3 id="操作系统的发展"><a class="markdownIt-Anchor" href="#操作系统的发展"></a> 操作系统的发展</h3><h4 id="操作系统的演变"><a class="markdownIt-Anchor" href="#操作系统的演变"></a> 操作系统的演变</h4><ul><li>单道批处理系统 串行执行预先组织好的一组任务，IO操作时CPU等待数据传输完成，浪费时间。</li><li>多道批处理系统 处理器可以交错运行多个程序。</li><li>分时系统 将处理器的运行时间分成数片，平均或者依照一定的权重分发给系统中的各用户使用。</li></ul><h4 id="硬件发展轨迹"><a class="markdownIt-Anchor" href="#硬件发展轨迹"></a> 硬件发展轨迹</h4><p>机械–电子管–晶体管–集成电路–大规模集成电路</p><h4 id="软件发展轨迹"><a class="markdownIt-Anchor" href="#软件发展轨迹"></a> 软件发展轨迹</h4><p>无软件–系统雏形–操作系统理论成型–现代操作系统–网络时代–开源软件时代</p><h4 id="单内核与微内核"><a class="markdownIt-Anchor" href="#单内核与微内核"></a> 单内核与微内核</h4><p>单内核，集中式操作系统，系统是个大模块，可分为若干逻辑模块，模块间以函数直接调用为交互。优点是内部调用效率高，缺点是各模块之间界限不特别清晰，系统升级或修改时牵一发而动全身，较难维护。</p><p>微内核，将操作系统中内存管理、设备管理等高级服务功能尽可能从内核中分离出来，使内核简洁可靠。优点是</p><ul><li>充分的模块化，方便第三方开发和设计模块。</li><li>未被使用的模块可以不必运行。</li><li>具有很高的可移植性。</li></ul><p>缺点是各模块与微内核之间通过通信机制交互，系统运行效率低。微内核是面向对象理论在操作系统设计中应用的产物。</p><h3 id="unixlinux操作系统"><a class="markdownIt-Anchor" href="#unixlinux操作系统"></a> Unix/Linux操作系统</h3><p>1969年 Ken Thompson 和 Dennis M. Ritchie 开发 Unix</p><p>1990年 Linus Torvalds 开发 Linux</p><h4 id="操作系统标准posix"><a class="markdownIt-Anchor" href="#操作系统标准posix"></a> 操作系统标准POSIX</h4><p>POSIX（可移植操作系统接口）由IEEE制定，由 ISO 接受为国际标准。其中POSIX 1003.1标准定义了一个最小的Unix操作系统接口，任何系统只有符合这个标准，才有可能运行Unix程序。</p><h4 id="gnu和linux"><a class="markdownIt-Anchor" href="#gnu和linux"></a> GNU和Linux</h4><p>GNU（GNU is Not Unix）是自由软件基金会的一个项目，该项目的目标是开发一个自由的Unix版本HURD。</p><p>Linux的开发使用了很多GNU工具，Linux内核、GNU工具以及其他一些自由软件组成了人们常说的Linux系统或Linux发行版。</p><h4 id="linux-开发模式"><a class="markdownIt-Anchor" href="#linux-开发模式"></a> Linux 开发模式</h4><p>开放与协作的开发模式，发挥集体智慧，减少重复劳动，经历了各种各样的测试和考验，具有很好的稳定性。</p><h3 id="linux内核"><a class="markdownIt-Anchor" href="#linux内核"></a> Linux内核</h3><p>Linux内核不是孤立的，需要放在整个系统中去研究。Linux系统由四部分组成：</p><ul><li><p>用户进程</p></li><li><p>系统调用接口</p><p>系统调用是内核代码的一部分</p></li><li><p>Linux内核</p></li><li><p>硬件</p></li></ul><p>Linux内核包含了系统调用接口和内核子系统。从程序员的角度，内核提供了一个与计算机硬件等价的、 扩展或虚拟的计算平台，它抽象了许多硬件细节，使程序能够按照某种统一的方式进行数据处理。从用户角度讲，内核是一个资源管理者，用户可以以某种易于理解的方式组织自己的数据。</p><h4 id="linux内核子系统"><a class="markdownIt-Anchor" href="#linux内核子系统"></a> Linux内核子系统</h4><p>Linux内核除了系统调用之外，由以下5个主要的子系统组成：</p><ul><li><p>进程调度</p><p>Linux使用了比较简单的、基于优先级和时间片的进程调度算法。</p></li><li><p>内存管理</p><p>支持虚拟内存，因为虚拟内存管理需要硬件支持，所以内存管理分为硬件无关部分和硬件相关部分。</p></li><li><p>虚拟文件系统</p></li><li><p>网络</p></li><li><p>进程间通信（IPC）</p></li></ul><p>处于中心地位的是进程调度。</p><h4 id="linux内核源代码"><a class="markdownIt-Anchor" href="#linux内核源代码"></a> Linux内核源代码</h4><p>版本号格式：x.y.z</p><p>第二位为偶数则为产品化版本，第二位为奇数则为实验版本，实验版本最初是产品化版本的副本；产品化版本只修改错误，实验版本继续增加新功能，到实验版本经测试稳定后再复制生成新的产品化版本。</p><p>Linux内核源代码位于<code>/user/src/linux</code>目录下，每个目录或子目录可以看作一个模块（结构化程序设计）</p><ul><li><code>include/</code>建立内核代码所需的大部分包含文件</li><li><code>init/</code>内核的初始化代码，这是内核工作的起点</li><li><code>arch/</code>包含Linux支持的所有硬件结构的内核代码</li><li><code>drivers/</code>内核中所有的设备驱动程序</li><li><code>fs/</code>所有文件系统的代码</li><li><code>net/</code>关于网络的代码</li><li><code>mm/</code>所有内存管理代码</li><li><code>ipc/</code>进程间通信的代码</li><li><code>kernel/</code>主内核代码</li></ul><h2 id="内存寻址"><a class="markdownIt-Anchor" href="#内存寻址"></a> 内存寻址</h2><p>Linux的设计中，它把与硬件相关的代码全部放到了arch目录下，对于众多的硬件平台，大家最熟悉的就是i386，即 Intel 80386 的体系结构。</p><h3 id="内存寻址简介"><a class="markdownIt-Anchor" href="#内存寻址简介"></a> 内存寻址简介</h3><p>Alan Turing 设想了一种结构简单但运算能力几乎无限强大的机器，它由控制器、读写头和一段假设无限长的带子组成。工作带相当于存储器，被划分成为大小相同的小格子，每个格子可以写一个字母，读写头可以在带子上随意移动，而控制器可以要求读写头读取下方的工作带上的字母。这种“数据连续存储和选择读取”的思想是目前人们使用的几乎所有机器运行机制的灵魂。计算机体系结构的核心问题之一就是如何有效地进行内存寻址。</p><p>Intel公司发明的8086处理器是16位的，它的设计寻址目标是1MB的内存空间，所以地址总线扩展到了20位，如何将16位地址映射到20位的地址空间，Intel公司设计了一个非常巧妙的方法，分段的方法。</p><p>8086处理器中设置了四个段寄存器：CS、DS、SS、ES，分别用于可执行代码段、 数据段、堆栈段及扩展段。每个段寄存器都是16位的，每条“访内”指令中的内部地址也是16位的，访问内存时，CPU自动地将内部地址与某个段寄存器的内容相加，即段寄存器左移4位加偏移地址，从而将16位地址映射到20位地址。</p><p>1982年，Intel 80286问世，他的地址空间长度增加到了24位，并且引入了保护模式的概念。为了与过去兼容，以前的模式被成为实模式。80386的数据总线扩展到32位，但仍然保留了段寄存器16位，80386以后的处理器统称为<strong>IA32</strong> (32bit Intel Architecture)。</p><h4 id="ia32寄存器简介"><a class="markdownIt-Anchor" href="#ia32寄存器简介"></a> IA32寄存器简介</h4><p>通用寄存器：</p><p>EAX，EBX，ECX，EDX，EBP，ESP，ESI，EDI，8个通用寄存器是8086寄存器的超集，可以拆开来用，他们的低位部分被当成8个16位寄存器，AX，BX……DI，AX……BX还可以继续分为8个8位寄存器，AH、AL……DH、DL。</p><p>段寄存器：</p><p>16位，保存的不是段的基地址，而是某个段的选择符，段基地址存放在描述符表中。</p><p>指令指针寄存器和标志寄存器：</p><p>指令指针寄存器EIP中存放下一条将要执行的指令的偏移量，这个偏移量是相对于代码段寄存器CS而言的。偏移量加段基地址就是下一条指令的地址。标志寄存器EFLAGS很多与16位FLAGS相同。</p><p>控制寄存器：</p><p>80386有4个32位控制寄存器：</p><p>CR0中主要介绍0位和31位，PE（Protected Enable）和PG（PaGing enable）。</p><table><thead><tr><th>PG</th><th>PE</th><th>工作方式</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>实模式，8080操作</td></tr><tr><td>0</td><td>1</td><td>保护模式，但不允许分页</td></tr><tr><td>1</td><td>0</td><td>出错（权限大小倒置）</td></tr><tr><td>1</td><td>1</td><td>允许分页的保护模式</td></tr></tbody></table><p>CR1未定义。</p><p>CR2页故障线性地址寄存器，保存最后一次出现缺页的全32位线性地址。</p><p>CR3是页目录基址寄存器，保存页目录的物理地址。</p><h4 id="物理地址-虚拟地址-线性地址"><a class="markdownIt-Anchor" href="#物理地址-虚拟地址-线性地址"></a> 物理地址、虚拟地址、线性地址</h4><p>对于操作系统来说，它既需要知道物理内存地址，又需要提供一套程序员使用的与硬件无关的虚拟的内存空间。</p><p>主板上的物理内存条所提供的内存空间称为物理内存空间，其中每个内存单元的实际地址称为物理地址；操作系统为程序员提供的与硬件无关的内存空间称为虚拟地址空间（或地址空间），其中的地址称为虚拟地址，通常用“段：偏移量”来描述。</p><p>线性地址空间是指一段连续的、不分段的、范围为0～4GB的地址空间，一个线性地址就是线性地址空间中的绝对地址。</p><p>地址的转换由内存管理单元（MMU）完成，其功能是把虚拟地址映射为物理地址。MMU是一种硬件电路，有分段和分页两个部分组成。分段机制将虚拟地址转换成线性地址，分页机制将线性地址转换成物理地址。</p><h3 id="分段机制"><a class="markdownIt-Anchor" href="#分段机制"></a> 分段机制</h3><p>段描述符表由段描述符组成，每个段描述符占8个字节（段基地址32位，界限20位，属性12位），在保护模式下有三种表：全局描述符表、中断描述符表、局部描述符表。</p><p>保护模式下IA32虚拟地址“段：偏移量”中的段不是段基地址，而是一个索引，段基地址通过索引在段描述符表中查找，因此保护模式下段寄存器中储存的是段描述符表的索引。段寄存器又可以叫做选择符，选择符有三个域，3～15位是索引域；第二位是TI位选择域，TI为0表示全局描述符表索引，TI为1表示局部描述符表索引；第0位和第1位为请求者的特权级RPL，保护模式提供4种特权级，一般操作系统只用到两个，00表示最高特权级，对应内核态，11表示最低特权级，对应用户态。</p><h4 id="地址转换及保护"><a class="markdownIt-Anchor" href="#地址转换及保护"></a> 地址转换及保护</h4><ul><li>段寄存器中装入段选择符，同时把某偏移地址放入某寄存器（如ESI、EDI）中；</li><li>根据段选择符中的索引、TI、RPL，进行一系列合法性检查，如果没有问题进行下一步；</li><li>将段描述符表中对应的段基地址和放入某寄存器中的偏移地址相加形成线性地址。</li></ul><h4 id="linux中的段机制"><a class="markdownIt-Anchor" href="#linux中的段机制"></a> Linux中的段机制</h4><p>大部分硬件平台都不支持分段机制，只支持分页机制，为了绕过IA32的分段机制，让段的基地址为0，段的界限为4GB，将虚拟地址直接映射到线性地址。</p><h3 id="分页机制"><a class="markdownIt-Anchor" href="#分页机制"></a> 分页机制</h3><p>线性地址划分为若干<strong>页</strong>，相应地，把物理地址空间划分为若干<strong>物理块（页面）</strong>，一般页的大小为4KB。</p><h4 id="页表"><a class="markdownIt-Anchor" href="#页表"></a> 页表</h4><p>由于页的大小是4KB，所以对应的物理基地址一定是4KB的整数倍，因此基地址的低12位总是0，那么可以用这12位存放页的属性，这样，32位足以描述页的映射关系，页表中的每一项（页表项）占4个字节就足够。</p><p>因为4GB线性空间划分为1M个4KB页，一个页表项占用4B，页表需要占用4MB空间，而且还要求是连续的空间，这样不现实，因此引入两级页表机制。</p><h4 id="页目录"><a class="markdownIt-Anchor" href="#页目录"></a> 页目录</h4><p>页目录记录页表的信息，4MB的页表数据再次分页，可以划分成1K个4KB页，每个页目录占用32位，因此页目录共占用4KB空间，刚好是一个页表的大小。</p><p>页目录具有与页表相似的结构：低12位总是为0，存放页目录的属性；高20位存放指向页表所在物理页面在内存的起始地址。</p><p>通过分页机制，可以得到具有两级页表的线性地址结构：</p><p>页目录：页：页内偏移量</p><p>伪代码为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> dir:<span class="number">10</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> page:<span class="number">10</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> offset:<span class="number">12</span>;</span><br><span class="line">&#125;LinearAddr;</span><br></pre></td></tr></table></figure><h4 id="页表项属性"><a class="markdownIt-Anchor" href="#页表项属性"></a> 页表项属性</h4><p>31～12位，物理页面基地址；11～0位，页属性</p><p>属性包括：</p><ul><li>0位，Present，若P=1，表示该页已装入内存，P=0则表示该页不在内存中；</li><li>1位和2位，read/write和user/supervisor位，这两位为页面提供硬件保护，当U/S=0时，只有内核态才能进行寻址，为1时，内核态和用户态都能寻址；</li><li>3位，page write-through，表示是否采用写透方式，即写内存又写高速缓存，为1表示启用写透方式；</li><li>4位，page cache disable，表示是否启用高速缓存，为1表示启用；</li><li>5位，访问位，当对相应的物理页面进行访问时，该位为1；</li><li>7位，page size，只适用于页目录项，如果为1，则页目录项指的是4MB大小的页；</li><li>9～11位，操作系统专用位，Linux没有将它们做特殊之用。</li></ul><h4 id="线性地址到物理地址的转换"><a class="markdownIt-Anchor" href="#线性地址到物理地址的转换"></a> 线性地址到物理地址的转换</h4><p>二级页表线性地址结构：</p><p>页目录（10位）：页（10位）：页内偏移量（12位）</p><p>转换成物理地址步骤：</p><ol><li>页目录10位左移2位后与CR3中的页目录起始地址相加，得到页目录项的物理地址；</li><li>读取页目录项，得到页表的起始地址；</li><li>页10位左移2位后与页表起始地址相加，得到页表项的物理地址；</li><li>读取页表项，得到物理页面起始地址；</li><li>物理页面地址加页内偏移量，得到线性地址对应的物理地址。</li></ol><h4 id="页面高速缓存cache"><a class="markdownIt-Anchor" href="#页面高速缓存cache"></a> 页面高速缓存（cache）</h4><p>CPU高速缓存自动保留处理器最近使用的32个页表项，下次访问就不必到内存中找了，平均来说大约有90%的命中率，大大加快访问速度。</p><h3 id="linux-中的分页机制"><a class="markdownIt-Anchor" href="#linux-中的分页机制"></a> Linux 中的分页机制</h3><p>Linux主要采用分页机制来实现虚拟内存管理，因为</p><ul><li>Linux绕过IA32的分段机制，段地址为0，所有进程都使用相同的线性地址空间，这样内存管理比较简单；</li><li>其他RISC处理器分段功能有限，为了保证可移植性。</li></ul><p>Linux使用三级分页模式，这是因为许多处理器是64位的，线性地址结构为：</p><p>总目录：中间目录：页表：页内偏移量</p><h2 id="linux中的汇编语言"><a class="markdownIt-Anchor" href="#linux中的汇编语言"></a> Linux中的汇编语言</h2><p>Linux 来源于Unix，Linux所使用的i386语言也起源于Unix。</p><h3 id="att与intel汇编语言比较"><a class="markdownIt-Anchor" href="#att与intel汇编语言比较"></a> AT&amp;T与Intel汇编语言比较</h3><h4 id="前缀"><a class="markdownIt-Anchor" href="#前缀"></a> 前缀</h4><p>Intel汇编语言中，寄存器和立即数都没有前缀，在AT&amp;T汇编语言中，寄存器前冠以<code>%</code>，立即数前冠以<code>$</code>。</p><p>Intel汇编语言中，十六进制和十进制数后缀分别为<code>h</code>和<code>b</code>，AT&amp;T汇编语言中，十六进制立即数前冠以<code>0x</code>。</p><h4 id="操作数的方向"><a class="markdownIt-Anchor" href="#操作数的方向"></a> 操作数的方向</h4><p>操作数方向相反，如</p><p>Intel<code>mov eax,[ecx]</code></p><p>AT&amp;T  <code>movl (%ecx),eax</code></p><h4 id="内存单元操作数"><a class="markdownIt-Anchor" href="#内存单元操作数"></a> 内存单元操作数</h4><p>Intel中使用<code>[]</code>，AT&amp;T中使用<code>()</code>，如</p><p><code>mov eax, [ebx+5]</code></p><p><code>movl 5(%ebx), %eax</code></p><h4 id="操作码后缀"><a class="markdownIt-Anchor" href="#操作码后缀"></a> 操作码后缀</h4><p>AT&amp;T的操作码后面有后缀，<code>l</code>表示长整数32位，<code>w</code>表示字16位，<code>b</code>表示字节8位；而在Intel汇编语言中，则要在内存单元操作数前加<code>byte ptr</code>或<code>dword ptr</code>。</p><h3 id="att汇编语言相关知识"><a class="markdownIt-Anchor" href="#att汇编语言相关知识"></a> AT&amp;T汇编语言相关知识</h3><p>在Linux源代码中，汇编语言扩展名为<code>.S</code>。</p><p>Linux中<code>objdump</code>命令可以进行反汇编。</p><p>Linux中最常见的可执行文件格式是ELF格式，<s>ld连接程序对其代码段虚拟地址的安排总是从<code>0x8000000</code>开始</s>， <em>似乎后续版本的ld不再这样做</em>。</p><h4 id="gnu汇编程序gnu-assemblygas和连接程序"><a class="markdownIt-Anchor" href="#gnu汇编程序gnu-assemblygas和连接程序"></a> GNU汇编程序（GNU ASsembly,GAS）和连接程序</h4><p>汇编和连接有两种方式：</p><ol><li><p>GAS和ld</p><p><code>as filename.S -o filename.o</code>命令生成目标文件；</p><p><code>ld filename.o -o filename</code>命令生成可执行文件。</p></li><li><p>GCC</p><p><code>gcc -o filename filename.S</code>一步到位，完成汇编和连接。</p></li></ol><h4 id="att汇编语言中的节section"><a class="markdownIt-Anchor" href="#att汇编语言中的节section"></a> AT&amp;T汇编语言中的节（section）</h4><p>节由<code>.section</code>关键词标识，编写汇编语言程序至少需要三种节：</p><ul><li><p><code>.section.data</code></p><p>包含已初始化的数据。</p></li><li><p><code>.section.bss</code></p><p>包含未初始化的数据，系统将程序装入内存时该部分变量都置0，这个节的变量不占用磁盘空间。</p><p>bss和data节在编译时会在4字节上对齐。</p></li><li><p><code>.section.text</code></p><p>这个节包含程序的代码，它是只读的。</p></li></ul><h1 id="进程"><a class="markdownIt-Anchor" href="#进程"></a> 进程</h1><h2 id="进程介绍"><a class="markdownIt-Anchor" href="#进程介绍"></a> 进程介绍</h2><p>进程是对正在运行的程序的一种抽象，是操作系统的核心概念之一。</p><p>现在所有的计算机都可以同时做很多事情，而CPU只有一个（或者数量有限），严格来说，CPU一次只能运行一道程序，CPU通过在不同程序之间来回切换来运行多个程序，这样就给用户一种同时运行的感觉，这种CPU在多道程序之间来回快速切换称为伪并行。进程概念的引入使得并行更容易理解和处理。</p><h3 id="程序和进程"><a class="markdownIt-Anchor" href="#程序和进程"></a> 程序和进程</h3><p>程序是文件，是机器代码指令和数据的集合，保存在外部存储器上，称为可执行映像（excutable image），如exe文件。</p><p>程序保存了一系列用户希望完成的工作和步骤，它仅仅是静态的体现在纸面上，而程序运行的具体实现过程由进程来完成。</p><p>进程代表程序的执行过程，它是一个动态的实体，随着程序中指令的运行而不断变化，在某个时刻进程的内容称为进程映像（process image）。</p><p>Linux是多任务操作系统，可以同时运行多个程序，每个程序的执行都有自己的进程，每个进程都有自己的执行环境。CPU在多个程序之间进行切换，也就是在各个进程之间切换，也就是切换进程的执行环境，因此，进程切换又称为“环境切换”或“上下文切换”，上下文指的是进程的执行环境。</p><h3 id="进程的层次结构"><a class="markdownIt-Anchor" href="#进程的层次结构"></a> 进程的层次结构</h3><p>进程是个动态的实体，具有生命周期。</p><p>在Linux系统中，通过fork系统调用来创建一个新的进程。新创建的进程是子进程，子进程同样可以调用fork。每个进程只有一个父进程，但可以有多个子进程，这样形成一棵完整的进程树。</p><h3 id="进程的状态"><a class="markdownIt-Anchor" href="#进程的状态"></a> 进程的状态</h3><p>为了对进程从产生到消亡的这个动态过程进行跟踪和描述，需要定义各种进程状态并制定状态间的转换策略。</p><p>不同操作系统对进程状态的定义不同，通常有三种最基本的进程状态：</p><ul><li>运行态：进程占有CPU，并在CPU上执行</li><li>就绪态：进程已经具备运行条件，但由于CPU忙而暂时不能运行</li><li>阻塞态：进程因等待某种事件的发生而暂时不能运行</li></ul><h2 id="进程控制块"><a class="markdownIt-Anchor" href="#进程控制块"></a> 进程控制块</h2><p>操作系统为了对进程进行管理，将进程的信息存放在一个结构体中，Linux中把这个结构体叫做task_struct。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//Process info</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="进程的状态-2"><a class="markdownIt-Anchor" href="#进程的状态-2"></a> 进程的状态</h3><p>在Linux 的设计中，考虑到任一时刻在CPU上运行的进程最多只有一个，而准备运行的进程有若干个，为了管理方便，把就绪态和运行态合并为一个状态——可运行态。把所有可运行态进程放进一个队列中，调度程序从这个队列中选取进程投入运行。</p><p>所有进程状态如下：</p><ul><li><p>可运行态 TASK_RUNNING</p><p>正在运行或准备运行</p></li><li><p>睡眠（或等待）态</p><ul><li><p>浅度睡眠态</p><p>进程正在被阻塞，等待资源有效时被唤醒，也可由其他进程通过信号或中断唤醒。</p></li><li><p>深度睡眠态</p><p>与浅度睡眠类似，但不可由其他进程通过信号和时钟中断唤醒。</p></li></ul></li><li><p>暂停状态</p><p>进程暂时停止执行等待某种处理，比如正在接受调试的进程。</p></li><li><p>僵死状态</p><p>进程执行结束，但未消亡。此时进程已经结束并释放大部分资源，但尚未释放PCB。</p></li></ul><h3 id="进程标识符"><a class="markdownIt-Anchor" href="#进程标识符"></a> 进程标识符</h3><p>进程标识符（PID）是32位无符号整数，每个进程都有唯一的PID。</p><p>每个进程都属于某个用户组，task_struct结构中定义了用户标识符和组标识符。</p><h3 id="进程之间的关系"><a class="markdownIt-Anchor" href="#进程之间的关系"></a> 进程之间的关系</h3><p>进程之间具有父子关系，一个进程可以创建很多子进程，子进程之间具有兄弟关系。因此task_struct结构需要储存这些关系</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> state;<span class="comment">//进程状态</span></span><br><span class="line">    <span class="keyword">int</span> pid,uid,gid;<span class="comment">//一些标识符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">parent</span>,*<span class="title">child</span>,*<span class="title">o_sibling</span>,*<span class="title">y_sibling</span>;</span><span class="comment">//一些亲属关系</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进程控制块的存放"><a class="markdownIt-Anchor" href="#进程控制块的存放"></a> 进程控制块的存放</h3><p>Linux把每个进程的PCB和内核栈存放在一起，共占用8KB，调用<code>alloc_task_struct()</code>函数分配该内存区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">task_union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> <span class="title">task</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">stack</span>[<span class="number">2408</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把PCB和内核栈放在一起的好处</p><ul><li><p>内核可以方便而快速地找到PCB</p><p><code>p=(struct task_struct *) STACK_POINTER &amp; 0xffffe000</code></p></li><li><p>避免在创建进程时动态分配内存</p><p>Linux中定义了一个current宏，用于表示当前正在运行的进程，可以像全局变量一样使用，如<code>current-&gt;pid</code></p></li></ul><h2 id="进程的组织方式"><a class="markdownIt-Anchor" href="#进程的组织方式"></a> 进程的组织方式</h2><h3 id="进程链表"><a class="markdownIt-Anchor" href="#进程链表"></a> 进程链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">prev_task</span>, *<span class="title">next_task</span>;</span></span><br></pre></td></tr></table></figure><p>链表的头和尾都是init_task，init_task是0号进程，永远不会被删除，它的PCB被静态地分配在内核数据段中。</p><p>要遍历整个链表，定义宏<code>for_each_task()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> for_each_task(p) \</span></span><br><span class="line"><span class="keyword">for</span>(p = &amp;init_task; (p = p-&gt;next_task) != &amp;init_task;)</span><br></pre></td></tr></table></figure><h3 id="散列表"><a class="markdownIt-Anchor" href="#散列表"></a> 散列表</h3><p>遍历整个链表是个效率很低的行为，为了能够快速根据PID找到PCB，定义了散列表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pid_hashfn(x) \</span></span><br><span class="line">((((x) &gt;&gt; <span class="number">8</span>) ^ (x)) &amp; (PIDHASH_SZ - <span class="number">1</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;HulGodhel 于 2020.11.06&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;操作系统概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#操作系统概述&quot;&gt;&lt;/a&gt; 操作系统概述&lt;/h2&gt;
&lt;h3 id=&quot;认识操作系统&quot;&gt;&lt;a class=&quot;</summary>
      
    
    
    
    <category term="Linux" scheme="http://happylzyy.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://happylzyy.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>嵌入式系统学习笔记</title>
    <link href="http://happylzyy.github.io/2020/06/07/embedded-system/"/>
    <id>http://happylzyy.github.io/2020/06/07/embedded-system/</id>
    <published>2020-06-07T01:20:09.000Z</published>
    <updated>2021-04-03T02:39:00.204Z</updated>
    
    <content type="html"><![CDATA[<h1 id="嵌入式系统"><a class="markdownIt-Anchor" href="#嵌入式系统"></a> 嵌入式系统</h1><p>HulGodhel于2020.06.07</p><hr /><h1 id="第一章-嵌入式系统概论"><a class="markdownIt-Anchor" href="#第一章-嵌入式系统概论"></a> 第一章 嵌入式系统概论</h1><h2 id="无所不在的嵌入式系统"><a class="markdownIt-Anchor" href="#无所不在的嵌入式系统"></a> 无所不在的嵌入式系统</h2><p>计算机将变的小巧玲珑，藏身于任何地方，又消失在任何地方;功能强大，无影无踪。</p><h3 id="嵌入式系统举例"><a class="markdownIt-Anchor" href="#嵌入式系统举例"></a> 嵌入式系统举例</h3><p>汽车控制系统。</p><h3 id="嵌入式的展现形式"><a class="markdownIt-Anchor" href="#嵌入式的展现形式"></a> 嵌入式的展现形式</h3><ul><li>功能越来越复杂</li><li>硬件功能越来越复杂</li><li>软件编写工作量越来越大</li></ul><p>因此，需要有一种新的驾驭硬件的软件编程规范。</p><h3 id="举例遥测和遥信"><a class="markdownIt-Anchor" href="#举例遥测和遥信"></a> 举例：遥测和遥信</h3><p>遥测（遥测信息）：远程测量。采集并传送运行的参数。</p><p>遥信（遥信信息）：远程信号。采集并传送各种开关量信息。</p><h3 id="什么叫嵌入"><a class="markdownIt-Anchor" href="#什么叫嵌入"></a> 什么叫嵌入？</h3><p>原意：“紧紧地埋入、镶入”</p><p>狭义：宿主、寄主</p><h3 id="嵌入式系统的概念"><a class="markdownIt-Anchor" href="#嵌入式系统的概念"></a> 嵌入式系统的概念</h3><ul><li>从技术的角度定义：以应用为中心，以计算机技术为基础，软件硬件可裁剪，适应应用系统对功能，可靠性，成本，体积，工号严格要求的专用计算机系统。</li><li>从系统的角度定义：嵌入式系统是设计完成复杂功能的硬件和软件，并使其紧密耦合在一起的计算机系统。术语嵌入式反映了这些系统通常是更大系统中的一个完整的部分称为嵌入的系统。嵌入的系统中可以共存多个嵌入式系统。</li><li>即使不可见，嵌入式系统也无处不在。嵌入式系统应用在工业自动化、国防、运输和航天领域中。例如神舟飞船和长征火箭中有很多嵌入式系统，导弹的制导系统也是嵌入式系统，高档汽车中有多大几十个嵌入式系统。</li><li>在日常生活中，人们使用各种嵌入式系统，但未必知道它们。事实上，几乎所有带一点“智能”的家电（全自动洗衣机、电脑电饭煲等）都是嵌入式系统。</li></ul><h3 id="嵌入式系统的应用领域"><a class="markdownIt-Anchor" href="#嵌入式系统的应用领域"></a> 嵌入式系统的应用领域</h3><p>交通管理、信息家电、智能玩具、机器人、军事电子、通信设备、网络设备、移动计算、医疗仪器、电子商务、环境监测、汽车电子、智能仪器、工控设备等等。</p><h2 id="嵌入式系统与单片机系统的区别"><a class="markdownIt-Anchor" href="#嵌入式系统与单片机系统的区别"></a> 嵌入式系统与单片机系统的区别</h2><h3 id="嵌入式系统不等于单片机系统"><a class="markdownIt-Anchor" href="#嵌入式系统不等于单片机系统"></a> 嵌入式系统不等于单片机系统</h3><ul><li>目前嵌入式系统的主流是以32位嵌入式微处理器为核心的硬件设计和基于实时操作系统（RTOS）的软件设计。</li><li>单片机系统多为4位、8位、16位机，不适合运行操作系统，难以进行较为复杂的运算和处理功能。</li><li>嵌入式系统强调基于平台的设计，软硬件协同设计，单片机大多采用软硬件流水设计。</li><li>嵌入式系统设计的核心是软件设计（大概占70%），单片机系统软硬件设计所占比例基本相同。</li></ul><h3 id="学习方法上的不同"><a class="markdownIt-Anchor" href="#学习方法上的不同"></a> 学习方法上的不同</h3><p>单片机学习一般从硬件入手，从硬件体系结构、汇编语言到硬件设计、软件设计。</p><p>嵌入式系统可以从软件入手，从应用层编程到操作系统移植，硬件平台设计较好，按单片机设计的流程较难掌握。</p><h3 id="嵌入式系统不等于pc机"><a class="markdownIt-Anchor" href="#嵌入式系统不等于pc机"></a> 嵌入式系统不等于PC机</h3><ul><li>嵌入式系统一般是专用系统，而计算机是通用计算平台</li><li>嵌入式系统的资源比PC少的多</li><li>嵌入式系统的软件故障带来的后果比PC机大的多</li><li>嵌入式系统一般采用实时操作系统</li><li>嵌入式系统大多有成本、功耗要求</li><li>嵌入式系统得到多种微处理体系的支持</li><li>嵌入式系统需要专用的开发工具</li></ul><h2 id="实时操作系统"><a class="markdownIt-Anchor" href="#实时操作系统"></a> 实时操作系统</h2><h3 id="实时操作系统定义"><a class="markdownIt-Anchor" href="#实时操作系统定义"></a> 实时操作系统定义</h3><blockquote><p>POSIX 1003.b 定义（一个用于实时编程的标准）</p><p>实时操作系统：能够在限定响应时间内提供所需水平服务的计算机系统</p></blockquote><blockquote><p>一般性定义</p><p>一个实时系统是指计算的正确性不仅取决于程序的逻辑性，也取决于结果产生的时间，如果系统的时间约束条件得不到满足，将会发生系统出错。</p></blockquote><p><strong>注意</strong>：实时并不等于快！他是一个相对的概念，确切定义应该是“及时”，即在系统允许的时间范围内完成任务。</p><h3 id="实时系统衡量指标"><a class="markdownIt-Anchor" href="#实时系统衡量指标"></a> 实时系统衡量指标</h3><ul><li>响应时间</li><li>吞吐量</li><li>生存时间</li></ul><h4 id="实时性"><a class="markdownIt-Anchor" href="#实时性"></a> 实时性</h4><p>从广义概念上讲，嵌入式系统都可以看成是一个实时系统。</p><h4 id="优缺点"><a class="markdownIt-Anchor" href="#优缺点"></a> 优缺点</h4><ul><li>优点：设计和扩展变得容易，使应用程序的设计过程大为简化。</li><li>缺点：嵌入式实时操作系统需要额外的ROM/RAM开销，2~5%的CPU额外负荷以及内核的费用。</li></ul><h2 id="嵌入式的特征"><a class="markdownIt-Anchor" href="#嵌入式的特征"></a> 嵌入式的特征</h2><ul><li>技术密集：嵌入式系统是计算机技术、微电子技术和行业技术相结合的产物。</li><li>成本敏感：嵌入式产品每一批次的产品数量大，单位成本对产品的市场前景和利润影响极大。</li><li>专用紧凑：嵌入式系统在体积、功耗、配置、处理能力、电磁兼容性等方面有明显的应用约束。</li><li>开发困难：无法直接在目标机上开发，需要宿主机和目标机之间建立连接，进行交叉开发。</li><li>安全可靠：可靠性要求极高，网络信息安全，防危安全</li><li>不可垄断：嵌入式是个分散的工业，没有哪个系列的处理器和操作系统能够垄断全部市场。</li><li>多种多样：嵌入式处理器种类繁多，外设随应用领域变化，操作系统五花八门，嵌入式开发工具不一，嵌入式系统实时性多样化，应用领域广泛。</li><li>及时响应：嵌入式系统需要实时性保障，能够尽可能快的对外部技术过程的请求发出响应，<strong>及时</strong>完成。</li><li>其他：确定性<ul><li>任务个数确定</li><li>每个任务<strong>执行时序</strong>确定</li><li>每个任务所占资源等确定</li><li>任务间通信延迟确定</li></ul></li></ul><h2 id="发展历程"><a class="markdownIt-Anchor" href="#发展历程"></a> 发展历程</h2><p>处理器集成度越来越高，RTOS功能越来越强大，嵌入式中间件迅速发展，开发环境逐渐完善，应用领域覆盖完全。</p><ul><li>萌芽阶段<ul><li>工业应用、军事应用</li><li>检测、伺服、指示功能</li><li>汇编语言</li><li>无操作系统</li><li>单芯片可编程控制器</li></ul></li><li>简单系统阶段<ul><li>家电、医疗、仪器仪表、通信</li><li>简单工具，xray，无gui</li><li>汇编语言</li><li>无OS，VRTX</li><li>8位MCUDSP</li></ul></li><li>RTOS阶段<ul><li>消费电子、手机、汽车电子等等</li><li>GUI、网络、文件系统等等</li><li>汇编、C、C++</li><li>32位嵌入式处理器</li></ul></li><li>网络化阶段<ul><li>智能家电、联网设备、无线终端等等</li><li>Internet、流媒体、数据库</li><li>Soc芯片、多核</li></ul></li></ul><h2 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h2><ul><li><p>按处理器位数划分：4、8、16、32、64位系统</p></li><li><p>按应用类别划分：</p></li><li><p>按系统的实时性划分</p><ul><li>硬实时   汽车的ABS和安全气囊系统、飞行控制系统、核电站控制系统</li><li>软实时   电视信号、证券交易</li><li>自适应实时   自动调整满足环境需要，保证性能级别</li></ul></li><li><p>按工业界应用的复杂程度划分</p><ul><li>简单单处理器系统</li><li>可扩展单处理器系统</li><li>复杂嵌入式系统</li><li>制造或过程控制中使用的计算机控制系统</li></ul></li></ul><h1 id="第二章-操作系统"><a class="markdownIt-Anchor" href="#第二章-操作系统"></a> 第二章 操作系统</h1><h2 id="存在的问题"><a class="markdownIt-Anchor" href="#存在的问题"></a> 存在的问题</h2><ol><li>各种逻辑分析、关系处理复杂，难度大</li><li>功能任务与逻辑判断混杂缠绕</li></ol><p>能否只编写功能任务代码？</p><h2 id="计算机操作系统"><a class="markdownIt-Anchor" href="#计算机操作系统"></a> 计算机操作系统</h2><ul><li>操作系统是一种为应用程序提供服务的系统软件，是一个完整计算机系统的有机组成部分。</li><li>从层次上看，操作系统位于计算机硬件之上，应用软件之下，所以也把它叫做应用软件的运行平台。</li><li>计算机硬件系统、操作系统、系统软件、应用软件</li></ul><h3 id="计算机操作系统的作用"><a class="markdownIt-Anchor" href="#计算机操作系统的作用"></a> 计算机操作系统的作用</h3><ul><li>它在计算机应用程序与计算机硬件之间，屏蔽了计算机硬件工作的一些细节，并对系统中的资源进行有效的管理。</li><li>通过提供函数（应用程序接口，API），从而使应用程序的设计人员得以在一个友好的平台上进行应用程序的设计和开发，大大地提高了应用程序的开发效率。</li><li>操作系统：用汇编语言编写的硬件抽象层，高级语言接口</li><li>从用户角度来看，它就是一大堆函数（API和系统函数），用户可以调用（普通调用或系统调用）它们来对系统资源进行操作。</li></ul><h3 id="操作系统的功能"><a class="markdownIt-Anchor" href="#操作系统的功能"></a> 操作系统的功能</h3><ul><li>任务管理：任务表</li><li>存储管理：存储分配表</li><li>文件管理：文件目录</li><li>处理器的管理</li><li>网络和通信管理</li><li>I/O设备管理：设备表</li></ul><p>总之，需要一大堆表。</p><h3 id="操作系统中经常使用的数据结构"><a class="markdownIt-Anchor" href="#操作系统中经常使用的数据结构"></a> 操作系统中经常使用的数据结构</h3><h4 id="数组"><a class="markdownIt-Anchor" href="#数组"></a> 数组</h4><ul><li>同一数据类型数据的集合</li><li>占用连续内存空间</li><li>其中所有元素名称相同，但每个元素都有一个编号</li><li>元素名去掉编号（下标），得到的是数组名，数组名是个指针</li><li>使用上的特点<ul><li>分类存放</li><li>检索速度快、恒定</li><li>占用连续空间大</li></ul></li><li>用于记录同类事物的表</li></ul><h4 id="位图"><a class="markdownIt-Anchor" href="#位图"></a> 位图</h4><p>位图是数组的一种特殊应用，记录事物的状态。</p><p>应用于登记表</p><h4 id="结构体"><a class="markdownIt-Anchor" href="#结构体"></a> 结构体</h4><ul><li>不同类型数据的集合</li><li>占用连续内存空间</li><li>使用上的特点<ul><li>不分类存放，但用来描述同一事物</li><li>检索速度快且恒定</li></ul></li><li>应用于通讯录中的一条记录、工具箱、厨房等等</li></ul><h4 id="链表"><a class="markdownIt-Anchor" href="#链表"></a> 链表</h4><ul><li><p>同类型数据的集合</p></li><li><p>不占用连续的内存空间</p></li><li><p>使用上的特点</p><ul><li>分类存放，但空间上不连续（不需要大量的连续存储空间）</li><li>检索速度慢，且耗费时间不固定</li></ul></li><li><p>应用于存放大量的较大的表，类似档案柜</p></li></ul><h4 id="队列"><a class="markdownIt-Anchor" href="#队列"></a> 队列</h4><p>按照先进先出的规则组织的数据结构，可以用数组实现也可以用链表实现</p><p>主要用于对象的排队</p><h4 id="堆栈"><a class="markdownIt-Anchor" href="#堆栈"></a> 堆栈</h4><p>按照先进后出的规则组织的数据结构，主要用数组实现</p><p>主要用于程序模块的嵌套运行</p><h3 id="什么是多任务操作系统"><a class="markdownIt-Anchor" href="#什么是多任务操作系统"></a> 什么是多任务操作系统</h3><p>简单地说，就是能用一个处理器<strong>并发</strong>（注意不是同时！！）地运行多个程序的计算机管理系统。</p><blockquote><p>并发</p><p>由同一个处理器轮换地运行多个程序。或者说是由多个程序轮班地占用处理器这个资源。且在占用这个资源的期间，并不一定能够把程序运行完毕。</p></blockquote><h4 id="程序的切换"><a class="markdownIt-Anchor" href="#程序的切换"></a> 程序的切换</h4><p>PC（程序计数器）是个指路器，它指向哪儿，处理器就去哪儿，所以，哪个程序占用了PC，哪个程序就占用了CPU。</p><p>所谓的切换就是将目标程序的地址存入PC中。</p><p>不同的计算机类型指令是不同的。</p><ul><li>数据传送指令</li><li>子程序返回指令（由堆栈弹出）</li><li>中断服务程序返回指令（由堆栈弹出）</li></ul><p>综上，系统是通过把待运行程序的地址赋给程序计数器PC来实现程序的切换。</p><h2 id="嵌入式操作系统"><a class="markdownIt-Anchor" href="#嵌入式操作系统"></a> 嵌入式操作系统</h2><h3 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h3><p>计算机系统由硬件和软件组成，在发展初期没有操作系统这个概念，用户使用<strong>监控程序</strong>来使用计算机。随着计算机技术的发展，计算机系统的硬件、软件资源也愈来愈丰富，监控程序已不能适应计算机应用的要求。于是在<strong>六十年代</strong>中期监控程序又进一步发展形成了<strong>操作系统</strong>(Operating System)。发展到现在，广泛使用的有三种操作系统即<strong>多道批处理操作系统、分时操作系统以及实时操作系统</strong>。</p><ul><li>多道批处理系统：适用于计算中心等较大的计算机系统</li><li>分时操作系统：适用于多个用户共享系统资源</li><li>实时操作系统：适用于嵌入式设备和有实时性要求的系统中</li></ul><h4 id="嵌入式系统的基本结构"><a class="markdownIt-Anchor" href="#嵌入式系统的基本结构"></a> 嵌入式系统的基本结构</h4><img src="https://s1.ax1x.com/2020/06/08/tWmQG6.png" alt="tWmQG6.png" border="0" width="40%"/><h4 id="嵌入式系统硬件组成"><a class="markdownIt-Anchor" href="#嵌入式系统硬件组成"></a> 嵌入式系统硬件组成</h4><img src="https://s1.ax1x.com/2020/06/08/tWmHeJ.png" alt="tWmHeJ.png" border="0" width="80%"/><h4 id="嵌入式系统软件组成"><a class="markdownIt-Anchor" href="#嵌入式系统软件组成"></a> 嵌入式系统软件组成</h4><img src="https://s1.ax1x.com/2020/06/08/tWnAYt.png" alt="tWnAYt.png" border="0"  width=80% /><h4 id="实时操作系统的特点"><a class="markdownIt-Anchor" href="#实时操作系统的特点"></a> 实时操作系统的特点</h4><p>IEEE 的实时UNIX分委会认为实时操作系统应具备以下的几点:</p><ul><li>异步的事件响应</li><li>切换时间和中断延迟时间确定</li><li>优先级中断和调度</li><li>抢占式调度</li><li>内存锁定</li><li>连续文件</li><li>同步</li></ul><p>总的来说实时操作系统是<strong>事件驱动</strong>的，能对来自外界的作用和信号在限定的时间范围内作出响应。它强调的是<strong>实时性</strong>、<strong>可靠性</strong>和<strong>灵活性</strong>, 与实时应用软件相结合成为有机的整体起着核心作用, 由它来管理和协调各项工作,为应用软件提供良好的运行软件环境及开发环境。</p><p>从实时系统的应用特点来看实时操作系统可以分为两种：<strong>一般实时操作系统</strong>和<strong>嵌入式实时操作系统</strong>。</p><p>一般实时操作系统应用于实时处理系统的上位机和实时查询系统等实时性较弱的实时系统，并且提供了开发、调试、运用一致的环境。</p><p>嵌入式实时操作系统应用于实时性要求高的实时控制系统，而且应用程序的开发过程是通过<strong>交叉开发</strong>来完成的，即开发环境与运行环境是不一致。嵌入式实时操作系统具有<strong>规模小</strong>(一般在几K～几十K 内)、<strong>可固化使用实时性强</strong>(在毫秒或微秒数量级上)的特点 。</p><h3 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h3><h4 id="前后台系统"><a class="markdownIt-Anchor" href="#前后台系统"></a> 前后台系统</h4><p>对基于芯片的开发来说，应用程序一般是一个<strong>无限的循环</strong>，可称为<strong>前后台系统</strong>或<strong>超循环系统</strong>。</p><p>很多基于微处理器的产品采用前后台系统设计，例如微波炉、电话机、玩具等。在另外一些基于微处理器应用中，从省电的角度出发，平时微处理器处在停机状态，所有事都靠<strong>中断服务</strong>来完成。</p><img src="https://s1.ax1x.com/2020/06/08/tWcbFJ.png" alt="tWcbFJ.png" border="0" width="80%"/><h4 id="操作系统"><a class="markdownIt-Anchor" href="#操作系统"></a> 操作系统</h4><p>操作系统是计算机中<strong>最基本的程序</strong>。操作系统负责计算机系统中全部软硬资源的<strong>分配与回收</strong>、<strong>控制与协调</strong>等并发的活动；操作系统提供用户接口，使用户获得良好的<strong>工作环境</strong>；操作系统为用户扩展新的系统功能提供软件平台。</p><img src="https://s1.ax1x.com/2020/06/08/tWguTg.png" alt="tWguTg.png" border="0" width="30%"/><h4 id="实时操作系统-2"><a class="markdownIt-Anchor" href="#实时操作系统-2"></a> 实时操作系统</h4><p>实时操作系统是一段在嵌入式系统启动后首先执行的<strong>背景程序</strong>，用户的应用程序是运行于RTOS之上的各个任务，RTOS根据各个任务的要求，进行<strong>资源</strong>(包括存储器、外设等)管理、消息管理、任务调度、异常处理等工作。在RTOS支持的系统中， <strong>每个任务均有一个优先级</strong>，RTOS根据各个任务的优先级，动态地切换各个任务，保证对实时性的要求。</p><h4 id="代码临界区"><a class="markdownIt-Anchor" href="#代码临界区"></a> 代码临界区</h4><p>代码的临界区也称为临界区，指<strong>处理时不可分割的代码</strong>，运行这些代码不允许被打断。一旦这部分代码开始执行，则<strong>不允许任何中断打入</strong>（这不是绝对的，如果中断不调用任何包含临界区的代码，也不访问任何临界区使用的共享资源，这个中断可能可以执行）。为确保临界区代码的执行，在进入临界区之前要<strong>关中断</strong>，而临界区代码执行完成以后要立即<strong>开中断</strong>。</p><h4 id="资源"><a class="markdownIt-Anchor" href="#资源"></a> 资源</h4><p>程序运行时可使用的<strong>软、硬件环境</strong>统称为资源。资源可以是输入输出设备，例如打印机、键盘、显示器。资源也可以是一个变量、一个结构或一个数组等。</p><h4 id="共享资源"><a class="markdownIt-Anchor" href="#共享资源"></a> 共享资源</h4><p>可以被一个以上任务使用的资源叫做<strong>共享资源</strong>。为了防止数据被破坏，每个任务在与共享资源打交道时，必须独占该资源，这叫做<strong>互斥</strong>。</p><img src="https://s1.ax1x.com/2020/06/08/tWoFfO.png" alt="tWoFfO.png" border="0" width="60%"/><h4 id="任务"><a class="markdownIt-Anchor" href="#任务"></a> 任务</h4><p>一个任务，也称作一个<strong>线程</strong>，是一个简单的程序，该程序可以认为CPU完全属于该程序自己。实时应用程序的设计过程，包括如何把问题分<strong>割成多个任务</strong>，每个任务都是整个应用的某一部分，每个任务被赋予一定的优先级，有它自己的一套CPU寄存器和自己的栈空间。</p><h4 id="任务切换"><a class="markdownIt-Anchor" href="#任务切换"></a> 任务切换</h4><p>当多任务内核决定运行另外的任务时，它保存正在运行任务的当前状态，即CPU寄存器中的全部内容。这些内容保存在任务的当前状态保存区，也就是任务自已的栈区之中。入栈工作完成以后，就把下一个将要运行的任务的当前状态从任务的栈中重新装入CPU的寄予存器，并开始下一个任务的运行。这个过程就称为<strong>任务切换</strong>。这个过程增加了应用程序的额外负荷。CPU的内部寄存器越多，额外负荷就越重。做任务切换所需要的时间取决于CPU有多少寄存器要入栈。</p><h4 id="内核"><a class="markdownIt-Anchor" href="#内核"></a> 内核</h4><p>多任务系统中，内核负责管理各个任务，或者说为<strong>每个任务分配CPU时间</strong>，并且负责任务之间的<strong>通信</strong>。内核提供的基本服务是<strong>任务切换</strong>。使用实时内核可以大大<strong>简化</strong>应用系统的设计，是因为实时内核允许将应用分成若干个任务，由<strong>实时内核来管理它们</strong>。内核需要<strong>消耗一定的系统资源</strong>，比如2％～5％的CPU运行时间、RAM和ROM等。</p><p>内核提供必不可少的系统服务，如信号量、消息队列、延时等。</p><h4 id="调度"><a class="markdownIt-Anchor" href="#调度"></a> 调度</h4><p>调度是内核的主要职责之一。<strong>调度就是决定该轮到哪个任务运行了</strong>。多数实时内核是基于<strong>优先级</strong>调度法的。每个任务根据其重要程度的不同被赋予一定的优先级。基于优先级的调度法指CPU总是让处在就绪态的优先级最高的任务先运行。然而究竟何时让高优先级任务掌握CPU的使用权，有两种不同的情况，这要看用的是什么类型的内核，是非占先式的还是占先式的内核。</p><h4 id="非占先式内核"><a class="markdownIt-Anchor" href="#非占先式内核"></a> 非占先式内核</h4><p>非占先式内核要求每个任务自我放弃CPU 的所有权。非占先式调度法也称作<strong>合作型多任务</strong>，各个任务彼此合作共享一个CPU。异步事件还是由中断服务来处理。中断服务可以使一个高优先级的任务由挂起状态变为就绪状态。但中断服务以后控制权还是回到原来被中断了的那个任务，直到该任务主动放弃CPU的使用权时，那个高优先级的任务才能获得CPU的使用权。</p><h4 id="占先式内核"><a class="markdownIt-Anchor" href="#占先式内核"></a> 占先式内核</h4><p>当<strong>系统响应时间</strong>很重要时，要使用占先式内核。因此绝大多数商业上销售的实时内核都是占先式内核。最高优先级的任务一旦就绪，总能得到CPU的控制权。当一个运行着的任务使一个比它优先级高的任务进入了就绪状态，当前任务的CPU使用权就被剥夺了，或者说被<strong>挂起</strong>了，那个高优先级的任务立刻得到了<strong>CPU的控制权</strong>。如果是中断服务子程序使一个高优先级的任务进入就绪态，中断完成时，中断了的任务被挂起，<strong>优先级高的那个任务开始运行</strong>。</p><h4 id="任务优先级"><a class="markdownIt-Anchor" href="#任务优先级"></a> 任务优先级</h4><p>任务的优先级是表示任务被调度的优先程度。每个任务都具有优先级。任务越重要，赋予的优先级应越高，越容易被调度而进入运行态。</p><h4 id="中断"><a class="markdownIt-Anchor" href="#中断"></a> 中断</h4><p>​    中断是一种<strong>硬件机制</strong>，用于通知CPU有个异步事件发生了。中断一旦被识别，CPU保存部分（或全部）上下文即部分或全部寄存器的值，跳转到专门的子程序，称为<strong>中断服务子程序</strong>（ISR）。中断服务子程序做事件处理，处理完成后，程序回到：</p><ol><li><p>在前后台系统中，程序回到后台程序</p></li><li><p>对非占先式内核而言，程序回到被中断了的任务</p></li><li><p>对占先式内核而言，让进入就绪态的优先级最高的任务开始运行</p></li></ol><img src="https://s1.ax1x.com/2020/06/08/tWbkVA.png" alt="tWbkVA.png" border="0" /><h4 id="时钟节拍"><a class="markdownIt-Anchor" href="#时钟节拍"></a> 时钟节拍</h4><p>​    时钟节拍是特定的<strong>周期性中断</strong>。这个中断可以看作是系统心脏的脉动。中断之间的时间间隔取决于不同应用，一般在10ms到200ms之间。时钟的节拍式中断使得内核可以将<strong>任务延时</strong>若干个整数时钟节拍，以及当任务等待事件发生时，提供<strong>等待超时的依据</strong>。时钟节拍率越快，系统的额外开销就越大。</p><h3 id="使用实时操作系统的必要性"><a class="markdownIt-Anchor" href="#使用实时操作系统的必要性"></a> 使用实时操作系统的必要性</h3><p>嵌入式实时操作系统在目前的嵌入式应用中用得越来越广泛，尤其在功能复杂、系统庞大的应用中显得愈来愈重要。在嵌入式应用中，只有把CPU嵌入到系统中，同时又把操作系统嵌入进去，才是真正的计算机嵌入式应用。使用实时操作系统主要有以下几个因素：</p><ul><li>嵌入式实时操作系统提高了<strong>系统的可靠性</strong>。</li><li>提高了开发效率，<strong>缩短了开发周期</strong>。</li><li>嵌入式实时操作系统充分发挥了32位CPU的多任务潜力。</li></ul><h3 id="实时操作系统的优缺点"><a class="markdownIt-Anchor" href="#实时操作系统的优缺点"></a> 实时操作系统的优缺点</h3><p>优点：在嵌入式实时操作系统环境下开发实时应用程序使<strong>程序的设计和扩展变得容易</strong>，不需要大的改动就可以增加新的功能。通过将应用程序分割成若干独立的任务模块，使应用程序的设计过程大为<strong>简化</strong>；而且对实时性要求苛刻的事件都得到了快速、可靠的处理。通过有效的系统服务，嵌入式实时操作系统使得系统资源得到更好的利用。</p><p>缺点：使用嵌入式实时操作系统需要<strong>额外的ROM/RAM开销</strong>，2~5%的CPU额外负荷，以及内核的费用。</p><h3 id="常见的嵌入式操作系统"><a class="markdownIt-Anchor" href="#常见的嵌入式操作系统"></a> 常见的嵌入式操作系统</h3><h4 id="嵌入式linux"><a class="markdownIt-Anchor" href="#嵌入式linux"></a> 嵌入式Linux</h4><p>uClinux是一个完全符合GNU/GPL公约的操作系统，完全开放代码。uClinux从Linux 2.0/2.4内核派生而来，沿袭了主流Linux的绝大部分特性。它保留了Linux的大部分优点：</p><p>稳定、良好的移植性、优秀的网络功能、完备的对各种文件系统的支持、以及标准丰富的API等。</p><h4 id="wince"><a class="markdownIt-Anchor" href="#wince"></a> WinCE</h4><p>Windows CE是微软开发的一个开放的、可升级的32位嵌入式操作系统，Win CE不仅继承了传统的Windows图形界面，并且在Win CE平台上可以使用Windows 95/98上的编程工具（如Visual Basic、Visual C++等）、使绝大多数的应用软件只需简单的修改和移植就可以在Windows CE平台上继续使用。</p><h4 id="vxworks"><a class="markdownIt-Anchor" href="#vxworks"></a> VxWorks</h4><p>VxWorks操作系统是美国WIND RIVER公司于1983年设计开发的一种嵌入式实时操作系统（RTOS），是嵌入式开发环境的关键组成部分。良好的持续发展能力、高性能的内核以及友好的用户开发环境，在嵌入式实时操作系统领域占据一席之地。它以其良好的可靠性和卓越的实时性被广泛地应用在通信、军事、航空、航天等高精尖技术及实时性要求极高的领域中，如卫星通讯、军事演习、弹道制导、飞机导航等，甚至在1997年4月登陆火星表面的火星探测器上也使用到了VxWorks。</p><h4 id="ose"><a class="markdownIt-Anchor" href="#ose"></a> OSE</h4><p>OSE主要是由ENEA Data AB 下属的ENEA OSE Systems AB负责开发和技术服务的，一直以来都充当着实时操作系统以及分布式和容错性应用的先锋，并保持良好的发展态势。</p><p>OSE的客户深入到电信，数据，工控，航空等领域，尤其在电信方面，该公司已经有了十余年的开发经验，同诸如爱立信，诺基亚，西门子等知名公司确定了良好的关系。</p><h4 id="nucleus"><a class="markdownIt-Anchor" href="#nucleus"></a> Nucleus</h4><p>Nucleus PLUS是为实时嵌入式应用而设计的一个抢先式多任务操作系统内核，其95％的代码是用ANSI C写成的，因此非常便于移植并能够支持大多数类型的处理器。<br />Nucleus PLUS采用了软件组件的方法。每个组件具有单一而明确的目的，通常由几个C及汇编语言模块构成，提供清晰的外部接口，对组件的引用就是通过这些接口完成的。由于采用了软件组件的方法，使Nucleus PLUS 的各个组件非常易于替换和复用。</p><h4 id="ecos"><a class="markdownIt-Anchor" href="#ecos"></a> eCos</h4><p>eCos是RedHat公司开发的源代码开放的嵌入式RTOS产品，是一个可配置、可移植的嵌入式实时操作系统，设计的运行环境为RedHat的GNUPro和GNU开发环境。eCOS的所有部分都开放源代码，可以按照需要自由修改和添加。eCOS的关键技术是操作系统可配置性，允许用户组和自己的实时组件和函数以及实现方式，特别允许eCOS的开发则定制自己的面向应用的操作系统，使eCos能有更广泛的应用范围。</p><h4 id="μcos-ii"><a class="markdownIt-Anchor" href="#μcos-ii"></a> μC/OS-II</h4><p>μC/OS-II是一个<strong>源码公开</strong>、可移植、可固化、<strong>可裁剪</strong>、<strong>占先式</strong>的实时多任务操作系统。其绝大部分源码是用ANSI C写的，使其可以方便的移植并支持大多数类型的处理器。μC/OS-II通过了联邦航空局（FAA）商用航行器认证。自1992年问世以来，μC/OS-II已经被应用到数以百计的产品中。μC/OS-II占用很少的系统资源，并且在高校教学使用是不需要申请许可证。</p><h4 id="android"><a class="markdownIt-Anchor" href="#android"></a> Android</h4><p>Android是一种基于Linux的自由及开放源代码的操作系统，主要使用于移动设备，由Google公司和开放手机联盟领导及开发。Android操作系统最初由Andy Rubin开发，主要支持手机。2005年8月由Google收购注资。2007年11月，Google与84家硬件制造商、软件开发商及电信营运商组建开放手机联盟共同研发改良Android系统。随后Google以Apache开源许可证的授权方式，发布了Android的源代码。</p><h4 id="ios"><a class="markdownIt-Anchor" href="#ios"></a> iOS</h4><p>IOS是苹果公司开发的类Unix商业操作系统，于2007年1月9日的Macworld大会上公布。</p><h4 id="ultron"><a class="markdownIt-Anchor" href="#ultron"></a> ulTRON</h4><p>TRON明确的设计目标使其甚至比Linux更适合于做嵌入式应用，内核小，启动速度快，即时性能好，也很适合汉字系统的开发。另外，TRON的成功还来源于如下两个重要的条件：</p><pre><code>    1. 它是免费的       2. 它已经建立了开放的标准，形成了较完善的软硬件配套开发环境，较好地形成了产业化</code></pre><h2 id="gnu计划"><a class="markdownIt-Anchor" href="#gnu计划"></a> GNU计划</h2><p>有译为“革奴计划”，是由理查德·斯托曼在1983年9月27日公开发起的，它的目标是创建一套完全自由的操作系统。<br />GNU是“GNU’s Not UNIX”的缩写，斯托曼宣布GNU应当发音为“Guh-NOO”（/ˈgnuː/ ）</p><ol><li>不论目的为何，可以自由使用该种软件。</li><li>研究该软件如何运作的自由，并且得以改写该软件来符合使用者自身的需求，取得该软件之源码为达成此目的之前提。</li><li>重新散布该软件的自由。</li><li>有改善再利用该软件的自由，并且可以发表改写版供公众使用，如此一来，整个社群都可以受惠，如前项，取得该软件之源码为达成此目的之前提。</li></ol><h1 id="μcos-ii微小内核分析"><a class="markdownIt-Anchor" href="#μcos-ii微小内核分析"></a> μC/OS-II微小内核分析</h1><h2 id="概述-2"><a class="markdownIt-Anchor" href="#概述-2"></a> 概述</h2><h3 id="μcos-ii微小内核简介"><a class="markdownIt-Anchor" href="#μcos-ii微小内核简介"></a> μC/OS-II微小内核简介</h3><p>μC/OS-II 嵌入式实时操作系统的源代码可以分成三部分：</p><ul><li>与硬件无关的内核代码</li><li>与处理器有关的移植代码</li><li>用户配置文件</li></ul><img src="https://s1.ax1x.com/2020/06/08/tWXwSx.png" alt="tWXwSx.png" border="0" /><h3 id="内核代码"><a class="markdownIt-Anchor" href="#内核代码"></a> 内核代码</h3><p>内核代码位于source目录下，提供了4个微小内核。它们分别位于source\SOURCE1（包含建立任务和延时功能）、source\SOURCE2（增加删除任务功能）、source\SOURCE3（增加信号量文件）和source\SOURCE4（增加删除信号量功能）。它们的功能依次增强，代码也依次增大。</p><p>以上代码并没有完全裁减到最小，还包含了一些参数校验代码等非必需代码，μC/OS-II的代码裁减功能也同时保留，这些代码大约50多行。</p><h3 id="移植代码"><a class="markdownIt-Anchor" href="#移植代码"></a> 移植代码</h3><p>移植代码分别为OS_CPU_C.C（移植代码C语言部分）、OS_CPU_a.S（移植代码汇编语言部分）、OS_CPU.H（移植代码头文件）和IRQ.INC（移植代码与芯片无关的中断处理接口程序）4个文件。</p><h3 id="配置文件"><a class="markdownIt-Anchor" href="#配置文件"></a> 配置文件</h3><p>配置文件是每个μC/OS-II程序必备的文件，而且不同的程序一般不一样，但大小基本上相同。配置文件范例位于H目录下，分别为INCLUDES.H（内核需要的头文件，对于特定的移植，一般不需要改变）和OS_CFG.H（内核配置的头文件，一般需要根据程序的需求修改其常量的内容）文件。<br />一般来说，每个应用程序都有自己的配置文件拷贝，并很可能与范例不同。</p><h3 id="函数说明"><a class="markdownIt-Anchor" href="#函数说明"></a> 函数说明</h3><h4 id="osinit"><a class="markdownIt-Anchor" href="#osinit"></a> OSInit</h4><table><thead><tr><th><strong>函数名称</strong></th><th>OSInit</th></tr></thead><tbody><tr><td><strong>函数原型</strong></td><td><code>void OSInit(void)</code></td></tr><tr><td><strong>功能描述</strong></td><td>初始化μC/OS-Ⅱ，无函数参数和返回值</td></tr><tr><td><strong>特殊说明</strong></td><td>必须在调用OSStart()函数之前调用OSInit()，而只有在调用OSStart()函数之后，μC/OS-Ⅱ才真正开始运行多任务</td></tr></tbody></table><h4 id="osstart"><a class="markdownIt-Anchor" href="#osstart"></a> OSStart</h4><table><thead><tr><th><strong>函数名称</strong></th><th>OSStart</th></tr></thead><tbody><tr><td><strong>函数原型</strong></td><td><code>void OSStart(void)</code></td></tr><tr><td><strong>功能描述</strong></td><td>启动μC/OS-II的多任务环境，无函数参数和返回值</td></tr><tr><td><strong>特殊说明</strong></td><td>在调用OSStart( )之前必须先调用OSInit ( )。在用户程序中OSStart( )只能被调用一次，第二次调用OSStart( )将不执行任何操作</td></tr></tbody></table><p>####　OSTaskCreate</p><table><thead><tr><th><strong>函数名称</strong></th><th>OSTaskCreate</th></tr></thead><tbody><tr><td><strong>函数原型</strong></td><td><code>INT8U OSTaskCreate (void (*task)(void *pd), void *pdata, OS_STK *ptos, INT8U prio)</code></td></tr><tr><td><strong>功能描述</strong></td><td>建立一个新任务。既可以在多任务环境启动之前，也可以在正在运行的任务中创建任务</td></tr><tr><td><strong>函数参数</strong></td><td>task：指向任务代码的指针（函数指针） pdata：传递给任务的参数(一个变量指针) ptos ：指向任务堆栈栈顶的指针       prio ：任务的优先级</td></tr><tr><td><strong>特殊说明</strong></td><td>任务堆栈必须声明为OS_STK类型。注意：在中断处理程序中不能建立任务。在任务中必须调用μC/OS提供的下述过程之一：延时等待、任务挂起、等待事件发生（等待信号量，消息邮箱、消息队列），以便其它任务也能获得CPU的使用权</td></tr></tbody></table><h4 id="ostimedly"><a class="markdownIt-Anchor" href="#ostimedly"></a> OSTimeDly</h4><table><thead><tr><th><strong>函数名称</strong></th><th>OSTimeDly</th></tr></thead><tbody><tr><td><strong>函数原型</strong></td><td><code>void OSTimeDly (INT16U ticks)</code></td></tr><tr><td><strong>功能描述</strong></td><td>将一个任务延时若干个时钟节拍，无函数返回值。延时时间的长度可从0到65535个时钟节拍，延时时间0表示不进行延时，函数将立即返回调用者，延时的具体时间依赖于系统每秒钟有多少时钟节拍（由文件OS_CFG…H中的常量OS_TICKS_PER _SEC设定）</td></tr><tr><td><strong>函数参数</strong></td><td>ticks：要延时的时钟节拍数</td></tr><tr><td><strong>特殊说明</strong></td><td>延时时间0表示不进行延时操作，而立即返回调用者。为了确保设定的延时时间，建议用户设定的时钟节拍数加1。例如，希望延时10个时钟节拍，可设定参数为11</td></tr></tbody></table><h4 id="ostimetick"><a class="markdownIt-Anchor" href="#ostimetick"></a> OSTimeTick</h4><table><thead><tr><th><strong>函数名称</strong></th><th>OSTimeTick</th></tr></thead><tbody><tr><td><strong>函数原型</strong></td><td><code>void OSTimeTick(void)</code></td></tr><tr><td><strong>功能描述</strong></td><td>在每次时钟节拍中断服务程序中被调用，无函数参数和返回值。OSTimeTick()检查处于延时状态的任务是否达到延时时间，或正在等待事件的任务是否超时</td></tr><tr><td><strong>特殊说明</strong></td><td>OSTimeTick()的运行时间和系统中的任务数直接相关，在任务或中断中都可以调用。如果在任务中调用，任务的优先级应该很高（优先级数字很小），这是因为OSTimeTick()负责所有任务的延时操作</td></tr></tbody></table><h4 id="ostaskdel"><a class="markdownIt-Anchor" href="#ostaskdel"></a> OSTaskDel</h4><table><thead><tr><th><strong>函数名称</strong></th><th>OSTaskDel</th></tr></thead><tbody><tr><td><strong>函数原型</strong></td><td><code>INT8U OSTaskDel (INT8U prio)</code></td></tr><tr><td><strong>功能描述</strong></td><td>删除一个指定优先级的任务。被删除的任务将回到休眠状态，任务被删除后可以用函数OSTaskCreate()重新建立</td></tr><tr><td><strong>函数参数</strong></td><td>prio ：指定要删除任务的优先级，如果为OS_PRIO_SELF则删除自身</td></tr><tr><td><strong>函数返回值</strong></td><td>OS_NO_ERR：函数调用成功 OS_TASK_DEL_IDLE：错误，试图删除空闲任务（Idle task） OS_TASK_DEL_ ERR：错误，指定要删除的任务不存在 OS_PRIO_INVALID：参数指定的优先级大于OS_LOWEST_PRIO OS_TASK_DEL_ISR：错误，试图在中断处理程序中删除任务</td></tr></tbody></table><h4 id="osintenter"><a class="markdownIt-Anchor" href="#osintenter"></a> OSIntEnter</h4><table><thead><tr><th><strong>函数名称</strong></th><th>OSIntEnter</th><th><strong>所属文件</strong></th><th>OS_CORE.C</th></tr></thead><tbody><tr><td><strong>函数原型</strong></td><td>void OSIntEnter (void)</td><td></td><td></td></tr><tr><td><strong>功能描述</strong></td><td>通知μC/OS-Ⅱ一个中断服务已开始执行，这有助于μC/OS-Ⅱ掌握中断嵌套的情况。通常OSIntExit()和OSIntEnter()联合使用，无函数参数和返回值</td><td></td><td></td></tr><tr><td><strong>特殊说明</strong></td><td>在中断服务程序中，如果保证直接递增OSIntNesting“<strong>原子操作</strong>”，中断服务程序使用直接递增OSIntNesting的方法而不调用OSIntEnter()函数 <strong>何为原子操作？在一个任务的执行过程中，如果有某些操作不希望在执行过程中被别的任务或中断打断，那么这些不希望被打断的操作就是原子操作</strong></td><td></td><td></td></tr></tbody></table><h4 id="osintexit"><a class="markdownIt-Anchor" href="#osintexit"></a> OSIntExit</h4><table><thead><tr><th><strong>函数名称</strong></th><th>OSIntExit</th><th><strong>所属文件</strong></th><th>OS_CORE.C</th></tr></thead><tbody><tr><td><strong>函数原型</strong></td><td>void OSIntExit(void)</td><td></td><td></td></tr><tr><td><strong>功能描述</strong></td><td>通知μC/OS-Ⅱ一个中断服务已执行完毕，这有助于μC/OS-Ⅱ掌握中断嵌套的情况。通常OSIntExit()和OSIntEnter()联合使用。当最后一层嵌套的中断执行完毕后，如果有更高优先级的任务准备就绪，μC/OS-Ⅱ会调用任务调度函数，在这种情况下，中断返回到更高优先级的任务而不是被中断了的任务。无函数参数和返回值</td><td></td><td></td></tr><tr><td><strong>特殊说明</strong></td><td>在任务级不能调用该函数。即使中断服务程序使用直接递增OSIntNesting的方法（没有调用OSIntEnter()），也必须调用OSIntExit()函数</td><td></td><td></td></tr></tbody></table><h4 id="禁止允许中断函数"><a class="markdownIt-Anchor" href="#禁止允许中断函数"></a> 禁止/允许中断函数</h4><table><thead><tr><th><strong>函数名称</strong></th><th>OS_ENTER_CRITICAL()和OS_EXIT_CRITICAL()</th><th><strong>所属文件</strong></th><th>移植代码</th></tr></thead><tbody><tr><td><strong>函数原型</strong></td><td>由移植代码决定</td><td></td><td></td></tr><tr><td><strong>功能描述</strong></td><td>一般来说，OS_ENTER_CRITICAL()和OS_EXIT_CRITICAL()为定义的宏，用来禁止、打开CPU的中断，无函数参数和返回值</td><td></td><td></td></tr><tr><td><strong>特殊说明</strong></td><td>OS_ENTER_CRITICAL()和OS_EXIT_CRITICAL()必须成对使用</td><td></td><td></td></tr></tbody></table><h4 id="ossemcreate"><a class="markdownIt-Anchor" href="#ossemcreate"></a> OSSemCreate</h4><table><thead><tr><th><strong>函数名称</strong></th><th>OSSemCreate</th><th><strong>所属文件</strong></th><th>OS_SEM.C</th></tr></thead><tbody><tr><td><strong>函数原型</strong></td><td>OS_EVENT *OSSemCreate (INT16U cnt)</td><td></td><td></td></tr><tr><td><strong>功能描述</strong></td><td>建立并初始化一个信号量</td><td></td><td></td></tr><tr><td><strong>函数参数</strong></td><td>cnt ：建立的信号量的初始值，可以取0到65535之间的任何值</td><td></td><td></td></tr><tr><td><strong>函数返回值</strong></td><td>正常 ： 指向分配给所建立的信号量的事件控制块的指针 NULL ：没有可用的事件控制块</td><td></td><td></td></tr><tr><td><strong>特殊说明</strong></td><td>必须先建立信号量，然后使用</td><td></td><td></td></tr></tbody></table><h4 id="ossempend"><a class="markdownIt-Anchor" href="#ossempend"></a> OSSemPend</h4><table><thead><tr><th><strong>函数名称</strong></th><th>OSSemPend</th><th><strong>所属文件</strong></th><th>OS_SEM.C</th></tr></thead><tbody><tr><td><strong>函数原型</strong></td><td>void OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *err)</td><td></td><td></td></tr><tr><td><strong>功能描述</strong></td><td>等待信号量：当任务调用OSSemPend()函数时，如果信号量的值大于零，那么OSSemPend()函数对该值减一并返回：如果调用时信号量等于零，那么OSSemPend()函数将任务加入该信号量的等待列表，任务将等待直到获得信号量或超时</td><td></td><td></td></tr><tr><td><strong>函数参数</strong></td><td>cnt ：建立的信号量的初始值，可以取0到65535之间的任何值</td><td></td><td></td></tr><tr><td><strong>特殊说明</strong></td><td>必须先建立信号量，然后使用，不允许在中断中调用该函数， 因为中断不能被挂起</td><td></td><td></td></tr></tbody></table><h4 id="ossempost"><a class="markdownIt-Anchor" href="#ossempost"></a> OSSemPost</h4><table><thead><tr><th><strong>函数名称</strong></th><th>OSSemPost</th><th><strong>所属文件</strong></th><th></th></tr></thead><tbody><tr><td><strong>函数原型</strong></td><td>INT8U OSSemPost (OS_EVENT *pevent)</td><td></td><td></td></tr><tr><td><strong>功能描述</strong></td><td>发送信号量：如果指定的信号量是零或大于零，OSSemPost（）函数递增该信号量并返回。如果有任务在等待信号量，则最高优先级的任务将得到信号量并进入就绪状态。然后进行任务调度，决定当前运行的任务是否仍然为处于最高优先级的就绪态的任务</td><td></td><td></td></tr><tr><td><strong>函数参数</strong></td><td>pevent ：指向信号量的指针，OSSemCreate()的返回值</td><td></td><td></td></tr><tr><td><strong>函数返回值</strong></td><td>OS_NO_ERR ：发送信号量成功 OS_SEM_OVF ：信号量的值溢出 OS_ERR_EVENT_TYPE ：pevent 不是指向信号量的指针 OS_ERR_PEVENT_NULL ：错误，pevent为NULL</td><td></td><td></td></tr><tr><td><strong>特殊说明</strong></td><td>必须先建立信号量，然后使用</td><td></td><td></td></tr></tbody></table><h4 id="ossemdel"><a class="markdownIt-Anchor" href="#ossemdel"></a> OSSemDel</h4><table><thead><tr><th><strong>函数名称</strong></th><th>OSSemDel</th><th><strong>所属文件</strong></th><th>OS_SEM.C</th></tr></thead><tbody><tr><td><strong>函数原型</strong></td><td>OS_EVENT *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *err)</td><td></td><td></td></tr><tr><td><strong>功能描述</strong></td><td>删除信号量：在删除信号量之前，应当删除可能会使用这个信号量的任务</td><td></td><td></td></tr><tr><td><strong>函数参数</strong></td><td>pevent：指向信号量的指针，OSSemCreate()的返回值 opt：定义信号量删除条件      －OS_DEL_NO_PEND：没有任何任务等待信号量才删除      －OS_DEL_ALWAYS：立即删除 err：用于返回错误码</td><td></td><td></td></tr><tr><td><strong>特殊说明</strong></td><td>(1)使用这个函数调用时，必须特别小心，因为其它任务可能还要用这个信号量 (2)当挂起任务就绪时，中断关闭时间与挂起任务数目有关 (3)其它任务并不知道信号量被删除，除非检查pevent是否指向NULL</td><td></td><td></td></tr></tbody></table><h2 id="最小内核"><a class="markdownIt-Anchor" href="#最小内核"></a> 最小内核</h2><h4 id="什么是任务"><a class="markdownIt-Anchor" href="#什么是任务"></a> 什么是任务</h4><p>在实时多任务系统下运行的应用软件程序就是任务。在没有使用OS的前后台系统中，我们可以认为main函数以及通过main函数调用的全体函数为一个任务。<br />通常将“并行程序执行的基本逻辑单位”称之为“任务”，也就是说任务是可以被分割为独立的且可并行执行的基本逻辑单位程序。一个任务的程序是顺序执行的，而不同任务的程序却是并行执行的。任务必须包括相互“独立”和“并行”执行两个方面。</p><h4 id="独立"><a class="markdownIt-Anchor" href="#独立"></a> 独立</h4><p>独立具体指任务不能彼此直接调用，也不能直接进行数据交换。通过内核进行任务调度和数据交换。</p><p>####　并行执行</p><p>想象相互独立的任务各自拥有一个CPU，每个CPU各自执行各自的任务，此即任务的并行执行。但实际上CPU只有一个，我们认为操作系统为每个任务<strong>虚拟了一个CPU</strong>。</p><p>####　任务的状态</p><p>在μC/OS-Ⅱ中，任务有5种状态，分别为睡眠状态、就绪状态、运行状态、等待状态和被中断状态。</p><p><a href="https://imgchr.com/i/t4ik8S"><img src="https://s1.ax1x.com/2020/06/09/t4ik8S.png" alt="t4ik8S.png" border="0" /></a></p><h4 id="任务控制快"><a class="markdownIt-Anchor" href="#任务控制快"></a> 任务控制快</h4><p>μC/OS-Ⅱ是通过任务控制块来管理任务的。任务控制块是一个<strong>基于链表的数据结构</strong>，任务控制块主要用于记录任务的堆栈栈顶指针、指向下一个任务控制块的指针、任务等待的延迟时间、任务的当前状态标志与任务的优先级别等一些与任务管理有关的属性。<br />当任务的CPU使用权被剥夺时，μC/OS-Ⅱ用任务控制块来保存该任务的状态，从而保证任务重新获得CPU使用权时从断点处执行。</p><h4 id="任务就绪算法"><a class="markdownIt-Anchor" href="#任务就绪算法"></a> 任务就绪算法</h4><p>所谓就绪状态是指任务准备运行但CPU没空，任务等待运行的状态。<br />任务就绪算法涉及“任务就绪表OSRdyTbl、映射表OSMapTbl、优先级判定表OSUnMapTbl以及变量OSRdyGrp和相关的任务优先级prio”，其中映射表OSMapTbl和优先级判定表OSUnMapTbl是2个常数表，用于查表算法。</p><h4 id="os初始化"><a class="markdownIt-Anchor" href="#os初始化"></a> OS初始化</h4><p>μC/OS-II必须通过函数OSInit()初始化后才可以使用，该函数仅调用OS_InitMisc()、OS_InitRdyList()、OS_InitTCBList()和OS_InitTaskIdle() 4个函数。</p><img src="https://s1.ax1x.com/2020/06/09/t4MYsP.png" alt="t4MYsP.png" border="0" /><h4 id="任务管理"><a class="markdownIt-Anchor" href="#任务管理"></a> 任务管理</h4><p>μC/OS-Ⅱ通过任务控制块对任务进行管理，创建任务实际上就是给任务代码分配一个任务控制块，通过调用函数OSTaskCreate()实现。<br />任务可以在多任务调度开始前建立，也可以在其它任务的执行过程中建立。在开始多任务调度之前，用户必须至少创建一个任务，但任务不能在中断服务程序（ISR）中建立。</p><h2 id="临界区与中断管理"><a class="markdownIt-Anchor" href="#临界区与中断管理"></a> 临界区与中断管理</h2><h2 id="任务的结束"><a class="markdownIt-Anchor" href="#任务的结束"></a> 任务的结束</h2><h2 id="信号量"><a class="markdownIt-Anchor" href="#信号量"></a> 信号量</h2><h2 id="删除信号量"><a class="markdownIt-Anchor" href="#删除信号量"></a> 删除信号量</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;嵌入式系统&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#嵌入式系统&quot;&gt;&lt;/a&gt; 嵌入式系统&lt;/h1&gt;
&lt;p&gt;HulGodhel	于2020.06.07&lt;/p&gt;
&lt;hr /&gt;
&lt;h1 id=&quot;第一章-嵌入式系统概论&quot;&gt;&lt;a class=</summary>
      
    
    
    
    <category term="嵌入式系统" scheme="http://happylzyy.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Embedded" scheme="http://happylzyy.github.io/tags/Embedded/"/>
    
  </entry>
  
  <entry>
    <title>Git 学习笔记</title>
    <link href="http://happylzyy.github.io/2020/06/06/git/"/>
    <id>http://happylzyy.github.io/2020/06/06/git/</id>
    <published>2020-06-06T06:00:00.000Z</published>
    <updated>2021-04-03T02:39:17.321Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git-学习"><a class="markdownIt-Anchor" href="#git-学习"></a> Git 学习</h1><p>HulGodhel 于2020.04.24</p><hr /><h2 id="从何而来"><a class="markdownIt-Anchor" href="#从何而来"></a> 从何而来</h2><p>Linux 之父 Linus 在 1991 年创建开源的 Linux 操作系统之后，多年来依靠全世界广大热心志愿者的共同建设，经过长足发展，现已成为世界上最大的服务器系统。系统创建之初，代码贡献者将源码文件发送给 Linus，由其手动合并。这种方式维持多年后，代码量已经庞大到人工合并难以为继，于是深恶集中式版本控制系统的 Linus 选择了一个分布式商业版本控制系统 BitKeeper，不过 Linux 社区的建设者们可以免费使用它。BitKeeper 改变了 Linus 对版本控制的认识，同时 Linus 发现 BitKeeper 有一些不足，而且有个关键性的问题使之不能被广泛使用，就是不开源。</p><p>在 2005 年，BitKeeper 所在公司发现 Linux 社区有人企图破解它，BitKeeper 决定收回 Linux 社区的免费使用权。Linus 对此事调节数周无果，找遍了当时已知的各种版本控制系统，没有一个看上眼的，一怒之下决定自己搞一个。Linus 花了十天时间用 C 语言写好了一个开源的版本控制系统，就是著名的 Git。</p><p>2007 年旧金山三个年轻人觉得 Git 是个好东西，就搞了一个公司名字叫 GitHub，第二年上线了使用 Ruby 编写的同名网站 GitHub，这是一个基于 Git 的免费代码托管网站（有付费服务）。十年间，该网站迅速蹿红，击败了实力雄厚的 Google Code，成为全世界最受欢迎的代码托管网站。2018 年 6 月，GitHub 被财大气粗的 Microsoft 收购。2019 年 1 月 GitHub 宣布用户可以免费创建私有仓库。根据 2018 年 10 月的 GitHub 年度报告显示，目前有 3100 万开发者创建了 9600 万个项目仓库，有 210 万企业入驻。</p><p>Git是一个功能强大的分布式版本控制系统。</p><h2 id="怎么安装"><a class="markdownIt-Anchor" href="#怎么安装"></a> 怎么安装</h2><h3 id="linux环境"><a class="markdownIt-Anchor" href="#linux环境"></a> Linux环境</h3><p>Linux环境下大多自带Git软件包，如果没有自带，可以通过软件包管理器安装。</p><p>我使用的系统发行版是Arch Linux，软件包管理器是pacman，对应的安装命令为<code>sudo pacman -S git</code>.</p><p>不同的发行版使用的软件包管理器可能不同：</p><ul><li>openSUSE<code>sudo zypper install git</code></li><li>Debian/Ubuntu          <code>sudo apt-get install git</code></li><li>CentOS/Fedora        <code>sudo yum -i git</code></li></ul><h3 id="windows环境"><a class="markdownIt-Anchor" href="#windows环境"></a> Windows环境</h3><p>到Git官网下载Git for Windows安装即可。</p><h3 id="macos环境"><a class="markdownIt-Anchor" href="#macos环境"></a> MacOS环境</h3><p>其实跟Linux环境差不多，大多自带Git，如果嫌自带Git版本太低，可以通过HomeBrew项目安装。</p><h2 id="基本操作"><a class="markdownIt-Anchor" href="#基本操作"></a> 基本操作</h2><h3 id="查看git-版本"><a class="markdownIt-Anchor" href="#查看git-版本"></a> 查看Git 版本</h3><p><code>git --version</code></p><h3 id="克隆仓库"><a class="markdownIt-Anchor" href="#克隆仓库"></a> 克隆仓库</h3><p><code>git clone [仓库地址]</code></p><h3 id="git-仓库的三大区域"><a class="markdownIt-Anchor" href="#git-仓库的三大区域"></a> Git 仓库的三大区域</h3><p>Git本地仓库有三个区域：工作区、暂存区、版本区。</p><ul><li></li></ul><h3 id="查看仓库的状态"><a class="markdownIt-Anchor" href="#查看仓库的状态"></a> 查看仓库的状态</h3><p>在仓库的主目录下执行命令<code>git status</code>。</p><h3 id="添加修改到暂存区"><a class="markdownIt-Anchor" href="#添加修改到暂存区"></a> 添加修改到暂存区</h3><p>增加新文件<code>git add [文件名]</code>。</p><p>如果对多个文件或目录进行了增删改，可以用命令<code>git add .</code>。</p><p>注意到，对目录内的文件进行更改，是对工作区的修改，而add命令是将修改添加到暂存区。</p><h3 id="撤销暂存区的修改"><a class="markdownIt-Anchor" href="#撤销暂存区的修改"></a> 撤销暂存区的修改</h3><p>暂存区记录了修改，当然可以撤销，使用命令<code>git reset -- [文件名]</code>或<code>git rm --cached [文件名]</code>。</p><p>如果命令不带文件名，则默认撤销暂存区所有更改。</p><h3 id="查看修改详情"><a class="markdownIt-Anchor" href="#查看修改详情"></a> 查看修改详情</h3><p><code>git diff</code>查看工作区更改。</p><p><code>git diff --cached</code>查看暂存区的全部更改。</p><h3 id="查看版本区的提交历史记录"><a class="markdownIt-Anchor" href="#查看版本区的提交历史记录"></a> 查看版本区的提交历史记录</h3><p><code>git log</code></p><ul><li><code>git log [分支名]</code>查看某分支的提交历史，不写分支名即默认查看当前所在分支。</li><li><code>git log --oneline</code>一行显示提交历史。</li><li><code>git log -n</code>显示最近的n个提交。</li><li><code>git log --author [贡献者名字]</code> 查看指定贡献者的提交记录。</li><li><code>git log --graph</code>图示法显示提交历史。</li><li><code>git log --reverse</code> 倒序查看提交记录。</li></ul><h3 id="提交暂存区的修改"><a class="markdownIt-Anchor" href="#提交暂存区的修改"></a> 提交暂存区的修改</h3><p>执行<code>git commit</code>命令生成一个新的提交，必须带选项<code>-m</code>用来提供该提交的备注。</p><h3 id="查看分支信息"><a class="markdownIt-Anchor" href="#查看分支信息"></a> 查看分支信息</h3><p><code>git branch -avv</code>可以用来查看全部的分支信息。</p><h3 id="将新增提交推送到远程仓库"><a class="markdownIt-Anchor" href="#将新增提交推送到远程仓库"></a> 将新增提交推送到远程仓库</h3><p><code>git push</code></p><h3 id="版本回退"><a class="markdownIt-Anchor" href="#版本回退"></a> 版本回退</h3><ol><li>执行<code>git reset --soft HEAD^</code>可以撤销最近的一次提交，将修改还原到暂存区。</li><li><code>--soft</code>表示软退回，<code>--hard</code>表示硬退回。</li><li><code>HEAD^</code>表示撤销一次提交，每加一个^,倒退一个版本。<code>HEAD~n</code>表示退回n个版本。</li><li>版本回退之后再次提交的版本会与远程仓库版本冲突（提交时间线分叉），这种情况下也可以将本地推送到远程仓库，需要加<code>-f</code>选项。</li><li>基于commit ID 的回退<code>git reset --hard [ID]</code>。</li></ol><h3 id="本地仓库的变化记录"><a class="markdownIt-Anchor" href="#本地仓库的变化记录"></a> 本地仓库的变化记录</h3><p><code>git reflog</code>可以查看本地仓库的每一次版本变化，可以通过commit ID回到任何位置。(如果不知道ID，可以使用<code>HEAD@&#123;n&#125;</code>回到最近n次提交版本变化前)</p><h2 id="git-分支操作"><a class="markdownIt-Anchor" href="#git-分支操作"></a> Git 分支操作</h2><h3 id="添加ssh关联授权"><a class="markdownIt-Anchor" href="#添加ssh关联授权"></a> 添加SSH关联授权</h3><p>通过在系统中创建SSH公钥，并将公钥放到GitHub账户中用于本地Git授权。</p><p>终端执行<code>ssh-keygen</code>，得到公钥和私钥，位于home目录<code>.ssh</code>文件夹中。</p><h3 id="为git命令设置别名"><a class="markdownIt-Anchor" href="#为git命令设置别名"></a> 为Git命令设置别名</h3><p><code>git config --global alias.[别名] [原命令]</code></p><p>设置的别名可以用<code>git config -l</code>查看。</p><h3 id="分支管理"><a class="markdownIt-Anchor" href="#分支管理"></a> 分支管理</h3><p><code>git fetch</code>可以将远程仓库的分支信息拉取到本地仓库（仅仅更新了本地的远程分支信息）。</p><p><code>git pull</code>命令可以将远程仓库的数据拉取到本地。</p><p><code>git rebase origin/master</code>使本地master分支基于远程仓库的master分支。</p><h3 id="创建分支"><a class="markdownIt-Anchor" href="#创建分支"></a> 创建分支</h3><p><code>git branch -avv</code>查看本地分支信息。</p><p>执行<code>git branch [分支名]</code>可以创建新分支。</p><p><code>git checkout [分支名]</code>切换分支。</p><p><code>git checkout -b [分支名]</code>创建并切换分支。</p><p><code>git push [主机名] [本地分支名]:[远程分支名]</code>将本地分支推送到远程分支。</p><p>本地新创建的分支没有跟踪上游分支，<code>git branch --set-upstream [主机名/上游分支名] [本地分支名]</code>创建关联。</p><p>解除关联可以用<code>git branch --unset-upstream [分支名]</code>。</p><p>推送时即建立关联<code>git push --set-upstream [主机名] [本地分支名]</code>。</p><p>删除远程分支有两种方法：</p><ul><li><code>git push [主机名]:[远程分支名]</code>原理是将空分支推送到远程分支，结果是删除远程分支。</li><li><code>git push [主机名] --delete [远程分支名]</code></li></ul><p>删除本地分支<code>git branch -D [分支名]</code>。</p><p>本地分支改名<code>git branch -m [原分支名] [新分支名]</code>。</p><h2 id="github多人协作"><a class="markdownIt-Anchor" href="#github多人协作"></a> GitHub多人协作</h2><h3 id="忽略文件"><a class="markdownIt-Anchor" href="#忽略文件"></a> 忽略文件</h3><p><code>.gitignore</code>文件中存放需要忽略的文件，比如缓存文件、备份文件、环境文件等等。该文件可以在建立仓库时由GitHub设置生成。</p><p>忽略文件模板:<a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a></p><h3 id="开源许可证"><a class="markdownIt-Anchor" href="#开源许可证"></a> 开源许可证</h3><p>可以选择自己喜欢的许可证，注意跟法律有关。</p><h3 id="三个按钮"><a class="markdownIt-Anchor" href="#三个按钮"></a> 三个按钮</h3><ul><li>Watch：这是一个下拉按钮，可以选择对此仓库关注、不关注、忽略等。</li><li>Star：如果觉得这个仓库很好，就点击这个按钮送一颗星，在淘宝提供刷星业务之前，仓库获得的星越多表示该项目越优秀。</li><li>Fork：在别人的仓库中点此按钮会克隆一个完全一样的仓库到自己的账号中，包括所有分支、提交等，但不会克隆 issue，当此仓库发生版本变化，不会自动同步到克隆的仓库里，反之亦然。</li></ul><h3 id="增加合作者"><a class="markdownIt-Anchor" href="#增加合作者"></a> 增加合作者</h3><p>在仓库设置Manage access中增加合作者用户名，选择正确的用户，发送邀请邮件通知。</p><h3 id="添加issue"><a class="markdownIt-Anchor" href="#添加issue"></a> 添加issue</h3><p>在组长仓库界面，可以添加一些项目任务或待解决的问题，即issue。可以指派一位或多位项目参与者来完成任务，同时GitHub会给被指派者发邮件提醒。</p><h2 id="git-多人协作"><a class="markdownIt-Anchor" href="#git-多人协作"></a> Git 多人协作</h2><h3 id="克隆fork仓库"><a class="markdownIt-Anchor" href="#克隆fork仓库"></a> 克隆fork仓库</h3><p>组员将组长的仓库fork一份给自己，然后在本地克隆这个的仓库。</p><h3 id="完成任务并推送到自己的仓库"><a class="markdownIt-Anchor" href="#完成任务并推送到自己的仓库"></a> 完成任务并推送到自己的仓库</h3><p>每个issue都有一个编号，当完成任务后，执行提交命令时，备注开头加上<code>fix #n</code>。当组长仓库的commit中出现此字样时，对应的issue将自动关闭。</p><h3 id="pull-request-检查合并pr"><a class="markdownIt-Anchor" href="#pull-request-检查合并pr"></a> Pull Request &amp; 检查合并PR</h3><p>Pull Request，即一个分支向另一个分支提出允许合并请求。提PR既可以在仓库内，也可以跨仓库。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;git-学习&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#git-学习&quot;&gt;&lt;/a&gt; Git 学习&lt;/h1&gt;
&lt;p&gt;HulGodhel 于2020.04.24&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;从何而来&quot;&gt;&lt;a class=&quot;mar</summary>
      
    
    
    
    <category term="Git" scheme="http://happylzyy.github.io/categories/Git/"/>
    
    
    <category term="Git" scheme="http://happylzyy.github.io/tags/Git/"/>
    
  </entry>
  
</feed>
